# üß© Abstract Classes & Abstract Methods in Java

## üîë 1. Abstract Class in Java

### ‚úÖ Definition:

A **class declared using the `abstract` keyword**.
It **can** contain:

- ‚úÖ Abstract methods (without body)
- ‚úÖ Concrete methods (with implementation)
- ‚úÖ Fields/constructors/blocks

üìå It **cannot be instantiated** directly ‚Äî it must be **inherited**.

```java
abstract class Animal {
    abstract void makeSound();  // abstract method
    void sleep() {              // concrete method
        System.out.println("Sleeping...");
    }
}
```

---

## üîë 2. Abstract Method in Java

### ‚úÖ Definition:

A method **without a body** (no `{}` block) ‚Äî just a signature.

```java
abstract void makeSound();
```

üìå Must be implemented by subclasses unless the subclass is also declared `abstract`.

---

## üìå Syntax Rules

| Rule                                                        | Description                                           |
| ----------------------------------------------------------- | ----------------------------------------------------- |
| üõë Abstract method must be inside abstract class            | `abstract void m1();` only valid if class is abstract |
| üõë Abstract class can't be instantiated                     | `new Animal()` ‚Üí ‚ùå Compile error                     |
| üõë Subclass must implement all abstract methods             | Or declare itself `abstract`                          |
| üõë Abstract method can't be `private`, `static`, or `final` | Makes no sense: can‚Äôt override static/final/private   |

---

## üèóÔ∏è Real-World Example: Bank Interest System

```java
abstract class Bank {
    abstract int getRateOfInterest(); // abstract method
}

class SBI extends Bank {
    int getRateOfInterest() {
        return 7;
    }
}

class PNB extends Bank {
    int getRateOfInterest() {
        return 8;
    }
}

public class Main {
    public static void main(String[] args) {
        Bank b;

        b = new SBI();
        System.out.println("SBI Interest: " + b.getRateOfInterest() + "%");

        b = new PNB();
        System.out.println("PNB Interest: " + b.getRateOfInterest() + "%");
    }
}
```

‚úÖ **Output:**

```ini
SBI Interest: 7%
PNB Interest: 8%
```

> You work with **Bank**, but you don‚Äôt know/care which bank until runtime ‚Üí ‚ú® _runtime polymorphism_

---

## üìò Real-World Metaphor

Imagine:

- `abstract class Vehicle` ‚Üí All vehicles have `startEngine()`, `stop()`, `fuelType()`
- But _how_ the engine starts is different in `ElectricCar` vs `DieselTruck`.

That‚Äôs abstraction:

- **What** to do is declared
- **How** to do it is delegated to subclasses

---

## üß™ C# Developer Comparison

| Concept         | Java                          | C#                             |
| --------------- | ----------------------------- | ------------------------------ |
| Abstract Class  | `abstract class Animal {}`    | `abstract class Animal {}`     |
| Abstract Method | `abstract void makeSound();`  | `public abstract void Bark();` |
| Instantiation   | ‚ùå `new Animal()` not allowed | ‚ùå `new Animal()` not allowed  |

---

## üõ°Ô∏è Bonus: Prevent Misuse with Abstract

Suppose we write a base service class:

```java
abstract class PaymentService {
    public abstract void process(double amount);
    public void log(String msg) {
        System.out.println("[LOG] " + msg);
    }
}
```

Now, each gateway can implement `process`:

```java
class StripeService extends PaymentService {
    public void process(double amount) {
        log("Processing Stripe: " + amount);
    }
}

class RazorPayService extends PaymentService {
    public void process(double amount) {
        log("Processing RazorPay: " + amount);
    }
}
```

---

## ‚ö†Ô∏è Abstract Class vs Concrete Class

| Feature                     | Abstract Class                           | Concrete Class             |
| --------------------------- | ---------------------------------------- | -------------------------- |
| Instantiation               | ‚ùå Not allowed                           | ‚úÖ Allowed                 |
| Abstract methods allowed?   | ‚úÖ Yes                                   | ‚ùå No                      |
| Can contain implementation? | ‚úÖ Yes (concrete methods too)            | ‚úÖ Yes                     |
| Purpose                     | Serve as a base / partial implementation | Full usable implementation |

---

## ü§ì Common Errors You‚Äôll Face

| Code                                       | Problem                                                   |
| ------------------------------------------ | --------------------------------------------------------- |
| `abstract void m();` in non-abstract class | ‚ùå "Missing method body or declared abstract"             |
| `new AbstractClass()`                      | ‚ùå "Cannot instantiate abstract class"                    |
| Not overriding all abstract methods        | ‚ùå "Class must be abstract or implement abstract methods" |
| `abstract static/final/private` method     | ‚ùå Illegal modifier combination                           |

---

## üß¨ When to Use Abstract Class?

Use it when:

- You want to define a **base class with shared code**
- But **leave some methods unimplemented**
- And allow polymorphism based on child type

‚úÖ You **can‚Äôt do this with interfaces** until Java 8+, and even then, abstract classes give more flexibility (like fields, constructors).

---

## üß† Summary

| üîπ Feature        | üîπ Description                                            |
| ----------------- | --------------------------------------------------------- |
| `abstract class`  | Partially implemented class that can't be instantiated    |
| `abstract method` | Method with no body; must be overridden                   |
| Use case          | Define common structure with partial logic                |
| Benefits          | Enforce implementation, enable polymorphism, share logic  |
| Real use          | Framework base classes (e.g., `HttpServlet`, `Component`) |
