# ğŸš€ **`Span<T>`, `Memory<T>`, and `ref struct` in C#**

> Work with memory like a ninja â€” fast, safe, and zero GC pressure ğŸ§ âš¡

---

## ğŸ§  Why These Types Exist?

Traditional collections like arrays and lists:

- **Allocate memory on the heap**
- Cause **GC pressure** when used frequently
- **Copy memory** when slicing or manipulating buffers

âœ… `Span<T>` and `Memory<T>` solve these problems by:

- **Referencing existing memory**
- Avoiding copies
- Working on **stack** memory safely

---

## ğŸ§µ 1. `Span<T>` â€“ Stack-Based, Fast, and Temporary

> A lightweight, **stack-only** structure that **represents a slice of contiguous memory**

```csharp
Span<int> span = stackalloc int[3] { 1, 2, 3 };
span[1] = 99;
```

âœ… No heap allocations
âœ… Slicing arrays without copying

---

### ğŸ“¦ Example: Slicing Without Copying

```csharp
int[] numbers = { 10, 20, 30, 40, 50 };
Span<int> slice = numbers.AsSpan(1, 3); // { 20, 30, 40 }
```

> âœ… `Span<T>` is just a **view** over the original array

---

## âš ï¸ Limitation: `Span<T>` Canâ€™t Escape the Stack

```csharp
public Span<int> GetSpan() // âŒ Not allowed
{
    int[] data = new int[10];
    return data.AsSpan(); // Cannot return Span from method
}
```

> âŒ `Span<T>` is a `ref struct`, so it **canâ€™t be boxed**, captured in lambdas, or stored on the heap.

---

## ğŸ“¦ 2. `Memory<T>` â€“ Heap-Safe & Async-Friendly

> `Memory<T>` is similar to `Span<T>`, but it **can live on the heap** and be returned from methods.

```csharp
Memory<byte> buffer = new byte[1024];
ProcessBuffer(buffer);

void ProcessBuffer(Memory<byte> mem)
{
    Span<byte> span = mem.Span; // convert back when needed
}
```

âœ… Safe to use in `async` methods
âœ… Can be passed across method boundaries

---

## ğŸ”¬ 3. `ReadOnlySpan<T>` & `ReadOnlyMemory<T>`

```csharp
ReadOnlySpan<char> letters = "Hady".AsSpan();
ReadOnlyMemory<char> roMem = "Wafa".AsMemory();
```

> âœ… Guarantees immutability â€” **read-only views of memory**

---

## ğŸ§¬ 4. `ref struct` â€“ The Building Block of `Span<T>`

> A `ref struct` is a struct that:

- **Must live on the stack**
- **Cannot be boxed**
- **Cannot be captured in closures**
- **Cannot be used in async/await methods**

```csharp
ref struct MyRefStruct
{
    public Span<int> Buffer;
}
```

âœ… Used to create **stack-safe, high-performance** data structures

---

## ğŸ“Š Summary Table

| Type                | Stack or Heap | Async-safe | Slicing | Allocation-Free   | Can Return |
| ------------------- | ------------- | ---------- | ------- | ----------------- | ---------- |
| `Span<T>`           | âœ… Stack      | âŒ No      | âœ… Yes  | âœ… Yes            | âŒ No      |
| `Memory<T>`         | âœ… Heap       | âœ… Yes     | âœ… Yes  | âŒ No (allocates) | âœ… Yes     |
| `ReadOnlySpan<T>`   | âœ… Stack      | âŒ No      | âœ… Yes  | âœ… Yes            | âŒ No      |
| `ReadOnlyMemory<T>` | âœ… Heap       | âœ… Yes     | âœ… Yes  | âŒ No             | âœ… Yes     |
| `ref struct`        | âœ… Stack      | âŒ No      | âœ… Yes  | âœ… Yes            | âŒ No      |

---

## ğŸ’¬ Interview Insight

> "Use `Span<T>` for high-performance slicing on the stack, and `Memory<T>` when you need to cross method boundaries or use async code. Both are key to writing fast, GC-free C#."

---

## ğŸ§  Real-World Analogy

| Concept      | Analogy                                                         |
| ------------ | --------------------------------------------------------------- |
| `Span<T>`    | A temporary **window** into a memory block ğŸªŸ (fast, stack-only) |
| `Memory<T>`  | A **safe, reusable pointer** to a memory chunk ğŸ§³ (heap-safe)   |
| `ref struct` | A **power tool** that works fast but with strict rules âš ï¸       |
