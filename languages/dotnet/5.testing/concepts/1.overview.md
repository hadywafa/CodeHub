# Mastering .NET Testing — Human‑Friendly Mentor Guide

Hi! I’ll mentor you end‑to‑end on testing .NET apps (Console, Web API, MVC/Razor). Expect plain language, deep detail, and lots of copy‑pasteable examples. If anything feels “robotic,” poke me and I’ll reshape it again.

---

## 🤔 Why testing (really) matters

Testing isn’t about pleasing a manager or hitting a % number. It’s a safety net that lets you:

- **Ship faster**: you refactor without fear.
- **Sleep better**: a red test catches bugs before users do.
- **Design better**: testable code usually means clean boundaries and small, focused functions.

> Think of tests as future‑you’s bodyguards. They’ll push back when a change accidentally breaks behavior.

---

## 🧱 The Testing Pyramid (and Ice‑Cream Cones to Avoid)

1. **Unit tests** (fast, isolated): 60–80%
2. **Integration tests** (slice through external boundaries): 15–30%
3. **E2E/UI tests** (slow, flaky if abused): 5–10%
4. **Contract/Consumer‑Driven**: targeted, only where you integrate with other teams/services
5. **Performance/Security/Load**: periodic, automated in nightly/weeklies

> Rule of thumb: push logic downward where it can be unit tested; keep controllers/thin adapters.

---

## 🧭 What you’ll be able to do (for real)

By the end, you’ll:

- Write **unit tests** that are fast and crystal‑clear.
- Create **integration tests** covering API + DB + external calls.
- Run **UI/E2E tests** (Playwright) for real user flows.
- Use **contract tests** (Pact) to stop breaking your consumers.
- Track **coverage** (Coverlet), **mutation score** (Stryker), and publish reports in CI.

We’ll practice on a small, realistic app so this sticks.

---

## 🧰 Core Stack

- **Frameworks**: xUnit (primary), NUnit or MSTest (alternatives)
- **Assertions**: FluentAssertions
- **Test Doubles**: Moq or NSubstitute
- **Data Builders/Gen**: AutoFixture, Bogus
- **HTTP Stubs**: WireMock.Net (or RichardSzalay.MockHttp for HttpClient)
- **Containers**: Testcontainers for .NET (spawns Postgres/Redis/Kafka in tests)
- **EF Core Testing**: InMemory provider (logic only), SQLite in‑memory (real relational), Respawn (DB reset)
- **Web Host Testing**: `WebApplicationFactory<TEntryPoint>` (ASP.NET Core)
- **UI/E2E**: Microsoft Playwright for .NET (preferred), Selenium only when required
- **Coverage**: Coverlet + ReportGenerator
- **Mutation Testing**: Stryker.NET
- **Contract Testing**: Pact.NET
- **Load/Perf**: k6 (CLI), BenchmarkDotNet (microbenchmarks)

---

## 🧰 Tooling (simple explanations)

- **xUnit** – the test framework that runs your tests.
- **FluentAssertions** – makes expectations read like English.
- **Moq / NSubstitute** – fake out dependencies (like an email service) so tests run fast and isolated.
- **AutoFixture / Bogus** – generate sample data so you don’t hand‑craft every object.
- **WireMock.Net** – spin a tiny HTTP server in tests to stub third‑party APIs.
- **Testcontainers** – start real Docker deps (Postgres/Redis) from your test code.
- **EF Core testing** – pick the right approach: InMemory (logic only), SQLite in‑memory (relational), or Testcontainers (full‑fat DB).
- **Playwright** – click around your UI like a real user would.
- **Coverlet + ReportGenerator** – coverage metrics and pretty HTML reports.
- **Stryker.NET** – mutation tests; proves your tests actually catch bugs.
- **Pact.NET** – consumer‑driven contract testing between apps/teams.

> You don’t need all of them on day one. We’ll add them as you climb the pyramid.

---

## 🏗️ Project structure you’ll actually enjoy

Keep test types separate so intent is obvious and pipelines can run them differently.

```ini
MyShop.sln
/src
  MyShop.Console      # background job/CLI
  MyShop.WebApi       # ASP.NET Core Minimal API or Controllers
  MyShop.Mvc          # MVC/Razor Pages frontend
/tests
  MyShop.UnitTests
  MyShop.IntegrationTests
  MyShop.E2ETests
  MyShop.ContractTests
```

**Why this layout?**

- Different runners/flags.
- Faster feedback (unit tests run first, always).
- Cleaner dependencies per test type.

---

## 🚀 Quick start (10‑minute setup)

```bash
# 1) Create solution + src projects
mkdir MyShop && cd MyShop
 dotnet new sln -n MyShop
 dotnet new console -n MyShop.Console -o src/MyShop.Console
 dotnet new webapi -n MyShop.WebApi -o src/MyShop.WebApi --use-minimal-apis
 dotnet new mvc -n MyShop.Mvc -o src/MyShop.Mvc

# 2) Create test projects
 dotnet new xunit -n MyShop.UnitTests -o tests/MyShop.UnitTests
 dotnet new xunit -n MyShop.IntegrationTests -o tests/MyShop.IntegrationTests
 dotnet new xunit -n MyShop.E2ETests -o tests/MyShop.E2ETests
 dotnet new xunit -n MyShop.ContractTests -o tests/MyShop.ContractTests

# 3) Wire projects into solution
 dotnet sln add src/**/**.csproj tests/**/**.csproj

# 4) Add core testing packages
 dotnet add tests/MyShop.UnitTests package FluentAssertions
 dotnet add tests/MyShop.UnitTests package Moq
 dotnet add tests/MyShop.UnitTests package AutoFixture
 dotnet add tests/MyShop.UnitTests package Bogus

 dotnet add tests/MyShop.IntegrationTests package Microsoft.AspNetCore.Mvc.Testing
 dotnet add tests/MyShop.IntegrationTests package WireMock.Net.StandAlone
 dotnet add tests/MyShop.IntegrationTests package Testcontainers
 dotnet add tests/MyShop.IntegrationTests package Respawn
 dotnet add tests/MyShop.IntegrationTests package FluentAssertions

 dotnet add tests/MyShop.E2ETests package Microsoft.Playwright
 dotnet add tests/MyShop.ContractTests package PactNet

 # Coverage & mutation tools
 dotnet add tests/**/ package coverlet.collector
 dotnet tool install -g dotnet-reportgenerator-globaltool
 dotnet tool install -g dotnet-stryker
```

> If you want, I can generate this skeleton with first tests for you next.

---

## 🧱 The Testing Pyramid (no fluff)

- **Unit tests (60–80%)** – tiny, fast, pure logic. No network, no disk.
- **Integration (15–30%)** – real framework plumbing (controllers, filters), real DB or realistic stubbed HTTP.
- **E2E/UI (5–10%)** – a few happy paths proving the app works in a browser.
- **Contract tests** – only where services talk across team boundaries.

> 🚨 Smell to avoid: an “ice‑cream cone” (tons of UI tests, few unit tests). Slow, flaky, painful.

---

## 1. Unit testing you’ll love reading

### Example: pure logic class

```csharp
public class PriceCalculator
{
    public decimal Total(decimal price, int qty, decimal discount) =>
        Math.Max(0, price * qty - discount);
}
```

**Readable test:**

```csharp
public class PriceCalculatorTests
{
    [Fact]
    public void Total_never_goes_below_zero()
    {
        // Arrange
        var sut = new PriceCalculator();

        // Act
        var total = sut.Total(price: 10m, qty: 1, discount: 20m);

        // Assert
        total.Should().Be(0m, "discounts cannot make totals negative");
    }
}
```

**Why it’s good:** short, one responsibility, clear message.

### Parameterized tests (cover variants quickly)

```csharp
public class VatCalculator
{
    public decimal AddVat(decimal net, decimal rate) => Math.Round(net * (1 + rate), 2);
}

public class VatCalculatorTests
{
    [Theory]
    [InlineData(100, 0.14, 114)]
    [InlineData(99.99, 0.14, 113.99)]
    public void AddVat_rounds_to_two_decimals(decimal net, double rate, decimal expected)
    {
        var sut = new VatCalculator();
        sut.AddVat(net, (decimal)rate).Should().Be(expected);
    }
}
```

### Faking dependencies with Moq (or NSubstitute)

```csharp
public interface IExchangeRates { decimal UsdToEgp(); }
public class FxService(IExchangeRates rates)
{
    public decimal ToEgp(decimal usd) => usd * rates.UsdToEgp();
}

public class FxServiceTests
{
    [Fact]
    public void ToEgp_uses_exchange_rate_once()
    {
        var rates = new Mock<IExchangeRates>();
        rates.Setup(r => r.UsdToEgp()).Returns(50m);

        var sut = new FxService(rates.Object);
        sut.ToEgp(2m).Should().Be(100m);

        rates.Verify(r => r.UsdToEgp(), Times.Once);
    }
}
```

**Guidelines:**

- Don’t mock everything. Only external seams (time, file system, HTTP, random).
- Prefer **constructor injection** so you can pass fakes easily.
- Give fakes realistic return values (Bogus helps).

### AutoFixture + Bogus (natural data)

```csharp
var fixture = new Fixture();
var order = fixture.Build<Order>()
    .With(o => o.Items, new Faker<OrderItem>()
        .RuleFor(i => i.Sku, f => f.Commerce.Ean13())
        .RuleFor(i => i.Price, f => f.Finance.Amount(1, 100))
        .Generate(3))
    .Create();
```

### Common unit‑test smells (and fixes)

- **Huge Arrange blocks** → use builders or AutoFixture.
- **Multiple asserts for different behaviors** → split into tests.
- **Private‑method testing** → test through public behavior.

---

## 2. Integration tests (slice through the app)

Goal: prove your app’s wiring works: routing, filters/middleware, model binding, real DB, and external calls.

### Minimal API example with test host

`Program.cs`

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/hello", () => Results.Ok(new { message = "hi" }));
app.Run();
public partial class Program { }
```

> The partial `Program` lets `WebApplicationFactory<Program>` find your entry point.

**Test:**

```csharp
public class HelloApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public HelloApiTests(WebApplicationFactory<Program> factory) => _client = factory.CreateClient();

    [Fact]
    public async Task GET_hello_returns_ok_and_message()
    {
        var res = await _client.GetAsync("/hello");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        var json = await res.Content.ReadFromJsonAsync<JsonElement>();
        json.GetProperty("message").GetString().Should().Be("hi");
    }
}
```

### Swapping services only for tests

```csharp
public class TestWebAppFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            services.RemoveAll<IEmailSender>();
            services.AddSingleton<IEmailSender, FakeEmailSender>();
        });
    }
}
```

### EF Core: choosing the right DB for tests

- **InMemory provider**: super fast, but **not relational** (no FK constraints). Good for domain logic that _happens_ to use a DbContext.
- **SQLite in‑memory**: behaves relationally; close to production without Docker.
- **Testcontainers (Postgres/SQL Server)**: highest fidelity; costs seconds per test class.

**SQLite in‑memory setup:**

```csharp
services.AddDbContext<AppDb>(o => o.UseSqlite("DataSource=:memory:"));
// Remember to open connection and run migrations in test setup
```

**Clean DB between tests with Respawn:**

```csharp
var respawner = await Respawner.CreateAsync(connection, new() { DbAdapter = DbAdapter.SqlServer });
await respawner.ResetAsync(connection);
```

### Stubbing external HTTP with WireMock.Net

```csharp
var server = WireMockServer.Start();
server.Given(Request.Create().WithPath("/rates").UsingGet())
      .RespondWith(Response.Create().WithStatusCode(200)
                               .WithBody("{ \"usdToEgp\": 50 }"));

var client = new HttpClient { BaseAddress = new Uri(server.Urls[0]) };
```

### Real deps with Testcontainers

```csharp
var pg = new PostgreSqlBuilder().WithImage("postgres:16").Build();
await pg.StartAsync();
// Use pg.GetConnectionString() in your DbContext options
```

**Integration test checklist:**

- Host app with `WebApplicationFactory`.
- Seed/clean DB deterministically (Migrations + Respawn).
- Stub or containerize external dependencies.
- Make tests idempotent and parallel‑friendly.

---

## 3. MVC/Razor UI & E2E tests (Playwright)

Use a few, meaningful flows: home page loads, login works, add‑to‑cart → checkout.

```csharp
[Fact]
public async Task Home_page_shows_title()
{
    await using var pw = await Playwright.CreateAsync();
    var browser = await pw.Chromium.LaunchAsync(new() { Headless = true });
    var page = await browser.NewPageAsync();
    await page.GotoAsync("https://localhost:5001/");

    (await page.TitleAsync()).Should().Contain("Home");
}
```

**Tips for stable UI tests:**

- Add `data-testid` attributes in views.
- Prefer role/text selectors over CSS jitter.
- Take screenshots on failure and keep logs.

---

## 4. Contract testing (Pact) in simple words

If your MVC (consumer) calls your Web API (provider), a contract test says: “For request X, I expect response Y.” The consumer writes this expectation → Pact produces a contract file → the provider verifies it in CI. Teams stop breaking each other.

```csharp
var pact = Pact.V3("MvcClient", "ShopApi", new PactConfig { PactDir = "./pacts" });
// define interactions in consumer tests, then verify on provider side
```

---

## 5. Performance & load (quick sanity, not premature obsession)

- **BenchmarkDotNet**: micro‑bench a hot method (e.g., pricing engine). Gives stable stats.
- **k6**: cheap HTTP load testing; run nightly and track regressions.

---

## 6. Snapshot/approval testing (great for JSON & HTML)

Use **Verify** to store expected output; if behavior changes, you get a diff.

```csharp
await Verify(jsonObject);
```

---

## 7. Coverage & mutation (quality you can trust)

### Coverage in CI

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutput=./coverage/ /p:CoverletOutputFormat=cobertura
reportgenerator -reports:coverage/coverage.cobertura.xml -targetdir:coverage-report
```

Open `coverage-report/index.html` and make decisions based on missed lines.

### Mutation testing with Stryker

```bash
stryker --solution MyShop.sln --reporter html
```

Aim for **> 70% mutation score** on critical libs. Low score? Your tests aren’t catching realistic bugs.

---

## 8. CI pipeline you can copy (GitHub Actions)

```yaml
name: tests
on: [push, pull_request]
jobs:
  unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: "9.0.x" }
      - run: dotnet restore
      - run: dotnet test tests/MyShop.UnitTests -c Release --collect:"XPlat Code Coverage" --logger trx
      - name: Report
        run: |
          dotnet tool update -g dotnet-reportgenerator-globaltool
          reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage-report
      - uses: actions/upload-artifact@v4
        with: { name: coverage-html, path: coverage-report }

  integration:
    runs-on: ubuntu-latest
    needs: unit
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: "9.0.x" }
      - run: dotnet test tests/MyShop.IntegrationTests -c Release --logger trx
```

Add Stryker as a separate (manual/nightly) job to save time.

---

## 🧪 Your practice app: **ShopRight** (end‑to‑end learning)

You’ll build a tiny store with:

- **Console job**: nightly ETL imports products from a CSV/HTTP feed.
- **Web API**: catalog + orders.
- **MVC**: simple UI to browse, add to cart, checkout.

**What you’ll test:**

- Unit: pricing rules, discount engine, inventory math.
- Integration: API endpoints with SQLite/Testcontainers; external exchange‑rate stub via WireMock.
- Contract: MVC (consumer) ↔ Web API (provider) using Pact.
- E2E: Playwright for happy paths.
- CI gates: coverage ≥ 80%, mutation ≥ 60%.

---

## ✅ Checklists you can keep on your desk

**Unit tests:**

- [ ] Clear Arrange / Act / Assert
- [ ] One reason to fail
- [ ] No real I/O (clock, file, network)
- [ ] FluentAssertions with helpful fail message

**Integration tests:**

- [ ] Host with `WebApplicationFactory`
- [ ] Run migrations; clean DB with Respawn
- [ ] Stub external HTTP or use Testcontainers
- [ ] Parallel‑safe and idempotent

**E2E/UI:**

- [ ] Stable selectors (`data-testid`)
- [ ] Minimal waits with explicit expectations
- [ ] Screenshots & traces on failure

---

## 🗓️ 4‑week plan (with plain‑English targets)

**Week 1 — Unit testing fluency:**

- Add xUnit + FluentAssertions + Moq.
- Write tests for 2–3 domain services (pricing, discounts, inventory).
- Refactor code to be injectable and testable.

**Week 2 — Integration confidence:**

- Add `WebApplicationFactory` tests for key API endpoints.
- Pick DB strategy (SQLite or Testcontainers) and wire Respawn.
- Stub an external HTTP call with WireMock.

**Week 3 — UI & contracts:**

- Add Playwright smoke flows.
- Introduce Pact: write one consumer contract and verify on provider.
- Add Verify for JSON snapshots where appropriate.

**Week 4 — Quality gates & CI:**

- Coverage HTML report in CI; fix blind spots.
- Run Stryker; raise mutation score.
- Stabilize flaky tests; keep E2E fast.

---

## 🧠 Final tips (human wisdom)

- Name tests like you’d explain to a teammate: `Method_Scenario_Result`.
- If a test is hard to write, your production code might be too coupled — refactor a seam.
- Keep tests fast: the best test suite is the one you actually run constantly.
- Prefer fewer, clearer E2E tests over dozens of brittle ones.
