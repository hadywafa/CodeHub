# 🎯 Unit Testing with xUnit — Beginner to Pro

## 🧭 What is Unit Testing (in human words)?

A **unit test** checks a _tiny piece_ of your code (a “unit”) in isolation.  
Think: “Given these inputs, I expect this exact output.”

Example in real life:

- You have a **calculator** → if you press `2 + 3`, you want `5`.
- The test is the script that checks: _does pressing `2 + 3` really give me `5`?_

Unit tests should be:

- **Fast** (milliseconds, not seconds).
- **Repeatable** (same result every run).
- **Isolated** (no DB, no API, no file system).

---

## ⚙️ Setting up xUnit

1. Create a test project:

   ```bash
   dotnet new xunit -n MyApp.UnitTests -o tests/MyApp.UnitTests
   dotnet sln add tests/MyApp.UnitTests/MyApp.UnitTests.csproj
   ```

2. Add `FluentAssertions` for readable assertions:

   ```bash
   dotnet add tests/MyApp.UnitTests package FluentAssertions
   ```

3. (Optional but recommended) Add `Moq` for mocking:

   ```bash
   dotnet add tests/MyApp.UnitTests package Moq
   ```

---

## 📝 Writing Your First Test

Let’s say we have a small **PriceCalculator** class:

```csharp
public class PriceCalculator
{
    public decimal Total(decimal price, int qty, decimal discount) =>
        Math.Max(0, price * qty - discount);
}
```

Here’s the **xUnit test**:

```csharp
using FluentAssertions;
using Xunit;

public class PriceCalculatorTests
{
    [Fact] // <- means "this is a test"
    public void Total_NeverGoesBelowZero()
    {
        // Arrange (setup)
        var sut = new PriceCalculator(); // sut = System Under Test

        // Act (do the thing)
        var total = sut.Total(price: 10m, qty: 1, discount: 20m);

        // Assert (check expectation)
        total.Should().Be(0m, "a discount cannot make totals negative");
    }
}
```

✅ Run it with:

```bash
dotnet test
```

---

## 🧪 Facts vs Theories

- `[Fact]` → a single test case.
- `[Theory]` → data-driven test, runs once per input row.

Example:

```csharp
public class VatCalculator
{
    public decimal AddVat(decimal net, decimal rate) => Math.Round(net * (1 + rate), 2);
}

public class VatCalculatorTests
{
    [Theory]
    [InlineData(100, 0.14, 114)]
    [InlineData(99.99, 0.14, 113.99)]
    public void AddVat_ShouldApplyCorrectly(decimal net, double rate, decimal expected)
    {
        var sut = new VatCalculator();
        sut.AddVat(net, (decimal)rate).Should().Be(expected);
    }
}
```

This avoids copy-paste: you feed multiple inputs, xUnit runs each as a separate test.

---

## 🔄 Arrange–Act–Assert Pattern (AAA)

This is the “grammar” of unit tests:

1. **Arrange**: setup the world.
2. **Act**: call the method under test.
3. **Assert**: verify outcome.

⚠️ Don’t mix them up, and leave blank lines between sections for readability.

---

## 🛑 Common Beginner Mistakes

- **Testing too much in one test**: split into small, focused tests.
- **Relying on external systems**: unit tests shouldn’t hit databases, HTTP, or files.
- **Bad naming**: use `Method_Scenario_ExpectedResult` or BDD style `Given_When_Then`.

Example:  
✅ `Total_WhenDiscountExceedsPrice_ReturnsZero`  
❌ `Test1`

---

## 📌 Checklist for Unit Tests

- [ ] Uses `[Fact]` or `[Theory]` clearly
- [ ] One clear reason to fail
- [ ] AAA structure visible
- [ ] Uses `FluentAssertions` for readable asserts
- [ ] No I/O or external dependencies

---

👉 Next, we can dive into **FluentAssertions** in detail (more expressive assertions) or jump to **Moq basics** (mocking dependencies).

Do you want me to expand **FluentAssertions** first (so your tests read like English), or go straight to **Moq** (so you can fake services)?
