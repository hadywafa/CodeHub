# 🧑‍💻 Real Examples of NSubstitute in Action

## 1. ✅ Guard Clauses (Don’t hit DB on bad input)

### Service

```csharp
public class UserService
{
    private readonly IUserRepository _repo;
    public UserService(IUserRepository repo) => _repo = repo;

    public User? GetUser(int id)
    {
        if (id <= 0) return null;  // guard clause
        return _repo.GetUserById(id);
    }
}
```

### Test

```csharp
[Fact]
public void GetUser_ShouldNotCallRepo_WhenIdIsInvalid()
{
    var repo = Substitute.For<IUserRepository>();
    var service = new UserService(repo);

    var result = service.GetUser(0);

    result.Should().BeNull();
    repo.DidNotReceive().GetUserById(Arg.Any<int>()); // 💡 ensures DB never touched
}
```

👉 Without `DidNotReceive()`, the test only checks null, but can’t guarantee the repo wasn’t called.

---

## 2. 📦 Caching (Only hit DB once)

### Service

```csharp
public class CachedUserService
{
    private readonly IUserRepository _repo;
    private readonly Dictionary<int, User> _cache = new();

    public CachedUserService(IUserRepository repo) => _repo = repo;

    public User GetUser(int id)
    {
        if (!_cache.ContainsKey(id))
            _cache[id] = _repo.GetUserById(id);

        return _cache[id];
    }
}
```

### Test

```csharp
[Fact]
public void GetUser_ShouldCallRepoOnlyOnce_WhenCalledTwice()
{
    var repo = Substitute.For<IUserRepository>();
    repo.GetUserById(1).Returns(new User { Name = "Ali" });

    var service = new CachedUserService(repo);

    service.GetUser(1);
    service.GetUser(1);

    repo.Received(1).GetUserById(1); // ✅ proves cache works
}
```

👉 If you only asserted the result (`Ali`), you wouldn’t know if the service secretly hit the DB twice.

---

## 3. 📧 Side Effects (Void methods)

### Service

```csharp
public class OrderService
{
    private readonly IOrderRepository _repo;
    private readonly IEmailService _email;

    public OrderService(IOrderRepository repo, IEmailService email)
    {
        _repo = repo;
        _email = email;
    }

    public void PlaceOrder(Order order)
    {
        _repo.Save(order);
        _email.Send(order.CustomerEmail, "Order Confirmation", "Thanks for your order!");
    }
}
```

### Test

```csharp
[Fact]
public void PlaceOrder_ShouldSendConfirmationEmail()
{
    var repo = Substitute.For<IOrderRepository>();
    var email = Substitute.For<IEmailService>();
    var service = new OrderService(repo, email);

    var order = new Order { CustomerEmail = "customer@test.com" };
    service.PlaceOrder(order);

    email.Received(1).Send("customer@test.com",
                           "Order Confirmation",
                           "Thanks for your order!");
}
```

👉 You can’t check a “return value” here, because the important behavior is the **side effect** — the email being sent.

---

## ⚖️ Recap

- **State-based** → Assert the result/output.
- **Interaction-based** → Assert that the service called dependencies correctly.

Use `Received()` when:

- You want to ensure **no unnecessary calls** (guards).
- You want to check **call counts** (caching, batching).
- You want to test **side effects** (logging, emails, messaging).

---

📌 So the magic is:

- `Returns` = fake responses to let your service run.
- `Received` = proof that your service **used the dependency correctly**.
