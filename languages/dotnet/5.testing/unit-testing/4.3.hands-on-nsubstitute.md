# ğŸ§‘â€ğŸ’» Real Examples of NSubstitute in Action

## 1. âœ… Guard Clauses (Donâ€™t hit DB on bad input)

### Service

```csharp
public class UserService
{
    private readonly IUserRepository _repo;
    public UserService(IUserRepository repo) => _repo = repo;

    public User? GetUser(int id)
    {
        if (id <= 0) return null;  // guard clause
        return _repo.GetUserById(id);
    }
}
```

### Test

```csharp
[Fact]
public void GetUser_ShouldNotCallRepo_WhenIdIsInvalid()
{
    var repo = Substitute.For<IUserRepository>();
    var service = new UserService(repo);

    var result = service.GetUser(0);

    result.Should().BeNull();
    repo.DidNotReceive().GetUserById(Arg.Any<int>()); // ğŸ’¡ ensures DB never touched
}
```

ğŸ‘‰ Without `DidNotReceive()`, the test only checks null, but canâ€™t guarantee the repo wasnâ€™t called.

---

## 2. ğŸ“¦ Caching (Only hit DB once)

### Service

```csharp
public class CachedUserService
{
    private readonly IUserRepository _repo;
    private readonly Dictionary<int, User> _cache = new();

    public CachedUserService(IUserRepository repo) => _repo = repo;

    public User GetUser(int id)
    {
        if (!_cache.ContainsKey(id))
            _cache[id] = _repo.GetUserById(id);

        return _cache[id];
    }
}
```

### Test

```csharp
[Fact]
public void GetUser_ShouldCallRepoOnlyOnce_WhenCalledTwice()
{
    var repo = Substitute.For<IUserRepository>();
    repo.GetUserById(1).Returns(new User { Name = "Ali" });

    var service = new CachedUserService(repo);

    service.GetUser(1);
    service.GetUser(1);

    repo.Received(1).GetUserById(1); // âœ… proves cache works
}
```

ğŸ‘‰ If you only asserted the result (`Ali`), you wouldnâ€™t know if the service secretly hit the DB twice.

---

## 3. ğŸ“§ Side Effects (Void methods)

### Service

```csharp
public class OrderService
{
    private readonly IOrderRepository _repo;
    private readonly IEmailService _email;

    public OrderService(IOrderRepository repo, IEmailService email)
    {
        _repo = repo;
        _email = email;
    }

    public void PlaceOrder(Order order)
    {
        _repo.Save(order);
        _email.Send(order.CustomerEmail, "Order Confirmation", "Thanks for your order!");
    }
}
```

### Test

```csharp
[Fact]
public void PlaceOrder_ShouldSendConfirmationEmail()
{
    var repo = Substitute.For<IOrderRepository>();
    var email = Substitute.For<IEmailService>();
    var service = new OrderService(repo, email);

    var order = new Order { CustomerEmail = "customer@test.com" };
    service.PlaceOrder(order);

    email.Received(1).Send("customer@test.com",
                           "Order Confirmation",
                           "Thanks for your order!");
}
```

ğŸ‘‰ You canâ€™t check a â€œreturn valueâ€ here, because the important behavior is the **side effect** â€” the email being sent.

---

## âš–ï¸ Recap

- **State-based** â†’ Assert the result/output.
- **Interaction-based** â†’ Assert that the service called dependencies correctly.

Use `Received()` when:

- You want to ensure **no unnecessary calls** (guards).
- You want to check **call counts** (caching, batching).
- You want to test **side effects** (logging, emails, messaging).

---

ğŸ“Œ So the magic is:

- `Returns` = fake responses to let your service run.
- `Received` = proof that your service **used the dependency correctly**.
