# ‚úçüèª Hands-on Moq

We‚Äôll use the same 3 scenarios you‚Äôd likely meet in real projects:

1. **Guard clause (no DB call on invalid input)**
2. **Caching (DB called only once)**
3. **Side effects (send email after saving)**

Each will use **Moq** in a practical way.

---

## 1Ô∏è‚É£ Guard Clause Example

### Code under test

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
}

public class UserService
{
    private readonly IUserRepository _repo;
    public UserService(IUserRepository repo) => _repo = repo;

    public User? GetUser(int id)
    {
        if (id <= 0) return null;  // guard clause
        return _repo.GetUserById(id);
    }
}
```

### Unit Test with Moq

```csharp
[Fact]
public void GetUser_ShouldNotCallRepository_WhenIdIsInvalid()
{
    // Arrange
    var repo = new Mock<IUserRepository>();
    var service = new UserService(repo.Object);

    // Act
    var result = service.GetUser(0);

    // Assert
    result.Should().BeNull();
    repo.Verify(r => r.GetUserById(It.IsAny<int>()), Times.Never);
}
```

üëâ Here, `Verify(..., Times.Never)` proves our guard clause prevents the repo from being touched.

---

## 2Ô∏è‚É£ Caching Example

### Code under test

```csharp
public class CachedUserService
{
    private readonly IUserRepository _repo;
    private readonly Dictionary<int, User> _cache = new();

    public CachedUserService(IUserRepository repo) => _repo = repo;

    public User GetUser(int id)
    {
        if (!_cache.ContainsKey(id))
            _cache[id] = _repo.GetUserById(id);

        return _cache[id];
    }
}
```

### Unit Test with Moq

```csharp
[Fact]
public void GetUser_ShouldOnlyCallRepoOnce_WhenCalledTwice()
{
    // Arrange
    var repo = new Mock<IUserRepository>();
    repo.Setup(r => r.GetUserById(1)).Returns(new User { Name = "Ali" });

    var service = new CachedUserService(repo.Object);

    // Act
    var firstCall = service.GetUser(1);
    var secondCall = service.GetUser(1);

    // Assert
    firstCall.Name.Should().Be("Ali");
    secondCall.Name.Should().Be("Ali");

    repo.Verify(r => r.GetUserById(1), Times.Once);
}
```

üëâ Without `Times.Once`, you wouldn‚Äôt know if the repo was called twice (wasting DB calls).

---

## 3Ô∏è‚É£ Side Effect Example (Email Sending)

### Code under test

```csharp
public interface IOrderRepository
{
    void Save(Order order);
}

public interface IEmailService
{
    void Send(string to, string subject, string body);
}

public class OrderService
{
    private readonly IOrderRepository _repo;
    private readonly IEmailService _email;

    public OrderService(IOrderRepository repo, IEmailService email)
    {
        _repo = repo;
        _email = email;
    }

    public void PlaceOrder(Order order)
    {
        _repo.Save(order);
        _email.Send(order.CustomerEmail, "Order Confirmation", "Thanks for your order!");
    }
}
```

### Unit Test with Moq

```csharp
[Fact]
public void PlaceOrder_ShouldSaveOrder_AndSendEmail()
{
    // Arrange
    var repo = new Mock<IOrderRepository>();
    var email = new Mock<IEmailService>();
    var service = new OrderService(repo.Object, email.Object);

    var order = new Order { CustomerEmail = "customer@test.com" };

    // Act
    service.PlaceOrder(order);

    // Assert
    repo.Verify(r => r.Save(order), Times.Once);
    email.Verify(e => e.Send("customer@test.com", "Order Confirmation", "Thanks for your order!"), Times.Once);
}
```

üëâ Here we‚Äôre not checking a return value ‚Äî we‚Äôre checking that **the right methods were invoked**.

---

## ‚úÖ Recap

- **Guard Clauses** ‚Üí `Verify(..., Times.Never)` ensures no unwanted calls.
- **Caching** ‚Üí `Verify(..., Times.Once)` guarantees efficiency.
- **Side Effects** ‚Üí `Verify()` confirms external actions (emails/logs/etc).

> üí° Moq, like NSubstitute, is all about **mocking dependencies**. The main difference is syntax:
>
> - Moq uses **Setup + Verify**.
> - NSubstitute uses **Returns + Received**.
