# ✨ FluentAssertions in .NET — Making Tests Read Like English

## 🤔 Why FluentAssertions?

The built-in `Assert` methods from xUnit work fine, but:

- They can be **ugly** (`Assert.Equal(expected, actual)`).
- Failure messages are often **not very helpful**.
- They don’t cover **complex scenarios** like comparing objects, collections, or exceptions in detail.

👉 FluentAssertions makes tests **expressive**, **readable**, and **self-explanatory**.

---

## 📦 Installing FluentAssertions

From your test project:

```bash
dotnet add package FluentAssertions
```

That’s it. Every test can now use `.Should()` extensions.

---

## 📝 Basic Usage

### Numbers and Strings

```csharp
[Fact]
public void Add_ShouldReturnCorrectResult()
{
    var calc = new Calculator();
    var result = calc.Add(2, 3);

    result.Should().Be(5);  // reads like English
}
```

✅ Failure message will be clear:

```ini
Expected result to be 5, but found 6.
```

---

### Collections

```csharp
[Fact]
public void Collection_ShouldContainExpectedItems()
{
    var numbers = new[] { 1, 2, 3 };

    numbers.Should().Contain(2);
    numbers.Should().HaveCount(3);
    numbers.Should().BeEquivalentTo(new[] { 1, 2, 3 }); // ignores order
}
```

---

### Strings

```csharp
[Fact]
public void String_ShouldStartAndEndCorrectly()
{
    var name = "FluentAssertions";

    name.Should().StartWith("Fluent")
        .And.EndWith("s")
        .And.Contain("Assert");
}
```

---

### Exceptions

```csharp
[Fact]
public void Divide_ByZero_ShouldThrow()
{
    var calc = new Calculator();

    Action act = () => calc.Divide(10, 0);

    act.Should().Throw<DivideByZeroException>()
       .WithMessage("*divide by zero*"); // wildcard supported
}
```

---

### Object Comparison

```csharp
public class User
{
    public string Name { get; set; }
    public int Age { get; set; }
}

[Fact]
public void Users_ShouldBeEquivalent()
{
    var user1 = new User { Name = "Ali", Age = 30 };
    var user2 = new User { Name = "Ali", Age = 30 };

    user1.Should().BeEquivalentTo(user2);
}
```

💡 `BeEquivalentTo` compares all properties by value, not by reference.

---

### Nullable & Booleans

```csharp
int? maybeNull = null;
maybeNull.Should().BeNull();

bool isValid = true;
isValid.Should().BeTrue();
```

---

### Advanced: Custom Assertions

You can even extend `.Should()` with your own logic:

```csharp
public static class CustomAssertionExtensions
{
    public static void BeEven(this FluentAssertions.Numeric.NumericAssertions<int> assertions)
    {
        Execute.Assertion
            .ForCondition(assertions.Subject % 2 == 0)
            .FailWith("Expected {context:int} to be even, but found {0}", assertions.Subject);
    }
}

[Fact]
public void Number_ShouldBeEven()
{
    4.Should().BeEven();
}
```

---

## 🎁 Why FluentAssertions Rocks

- ✅ **Readable** → `user.Age.Should().BeGreaterThan(18)`
- ✅ **Rich diagnostics** → clear failure messages
- ✅ **Supports everything** → strings, collections, objects, tasks, async code, exceptions
- ✅ **Extensible** → write your own assertions

---

## 📌 Quick Recap

- FluentAssertions replaces ugly `Assert.Equal` style with natural language `.Should().Be()`.
- Works with **numbers, strings, collections, objects, exceptions, tasks**.
- Makes test failures **clear and helpful**.
- Perfect match with xUnit’s `[Fact]` and `[Theory]`.
