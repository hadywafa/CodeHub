# 🕵️ Moq — Faking Dependencies in Unit Tests

## 🤔 Why Do We Need Moq?

Unit tests should check **only one unit of code**.
But in real life, classes often depend on **other services**:

- Database repositories
- Email senders
- External APIs

👉 If you call real dependencies in unit tests, you break the rules:

- Tests become slow ⏳ (waiting for DB or network).
- Tests become flaky 🎲 (fails if DB is offline).
- You’re not testing _your_ logic, you’re testing _their_ logic.

**Solution:** Mock the dependencies → replace real ones with **fake objects** that behave however we want.

---

## 📦 Installing Moq

```bash
dotnet add package Moq
```

---

## 📐 The Core Idea

- You create a **mock object** of an interface or class.
- You configure it → _“when method X is called, return Y”_.
- You pass it into your class under test.
- You verify later → _“was this method called?”_.

---

## 📝 Example 1: Simple Mock

Let’s say we have an **IEmailService**:

```csharp
public interface IEmailService
{
    void Send(string to, string subject, string body);
}
```

And a class that uses it:

```csharp
public class OrderProcessor
{
    private readonly IEmailService _emailService;

    public OrderProcessor(IEmailService emailService)
    {
        _emailService = emailService;
    }

    public void ProcessOrder(string customerEmail)
    {
        // some business logic...
        _emailService.Send(customerEmail, "Order Confirmed", "Thanks for your order!");
    }
}
```

### Test with Moq:

```csharp
using Moq;
using Xunit;
using FluentAssertions;

public class OrderProcessorTests
{
    [Fact]
    public void ProcessOrder_ShouldSendEmail()
    {
        // Arrange
        var emailMock = new Mock<IEmailService>();
        var processor = new OrderProcessor(emailMock.Object);

        // Act
        processor.ProcessOrder("test@example.com");

        // Assert
        emailMock.Verify(
            e => e.Send("test@example.com", "Order Confirmed", It.IsAny<string>()),
            Times.Once
        );
    }
}
```

💡 Explanation:

- `new Mock<IEmailService>()` → creates a fake email service.
- `emailMock.Object` → the fake instance we pass to our class.
- `Verify` → check if the method was called (with expected arguments).

---

## 📝 Example 2: Returning Values

If your dependency has return values:

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
}

public class UserService
{
    private readonly IUserRepository _repo;
    public UserService(IUserRepository repo) => _repo = repo;

    public string GetUserName(int id) => _repo.GetUserById(id)?.Name ?? "Unknown";
}
```

Test with Moq:

```csharp
[Fact]
public void GetUserName_ShouldReturnName()
{
    // Arrange
    var repoMock = new Mock<IUserRepository>();
    repoMock.Setup(r => r.GetUserById(1)).Returns(new User { Name = "Ali" });

    var service = new UserService(repoMock.Object);

    // Act
    var name = service.GetUserName(1);

    // Assert
    name.Should().Be("Ali");
}
```

💡 `Setup` → defines behavior when method is called.

---

## 🎭 Moq Key Features

### 1. Setup with Conditions

```csharp
mock.Setup(r => r.GetUserById(It.IsAny<int>()))
    .Returns(new User { Name = "Guest" });
```

- `It.IsAny<int>()` = wildcard matcher.

---

### 2. Verify Method Calls

```csharp
mock.Verify(r => r.GetUserById(5), Times.Once);
```

Checks method was called once with parameter `5`.

---

### 3. Throwing Exceptions

```csharp
mock.Setup(r => r.GetUserById(99))
    .Throws(new KeyNotFoundException());
```

---

### 4. Properties

```csharp
mock.SetupProperty(m => m.SomeValue, 42);
mock.Object.SomeValue.Should().Be(42);
```

---

### 5. Callbacks (Side Effects)

```csharp
string? capturedEmail = null;
emailMock.Setup(e => e.Send(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()))
         .Callback<string, string, string>((to, subject, body) => capturedEmail = to);

processor.ProcessOrder("test@example.com");
capturedEmail.Should().Be("test@example.com");
```

---

## 🛑 Common Mistakes with Moq

1. **Over-mocking** 🤯

   - If everything is mocked, you’re testing nothing.
   - Only mock _external dependencies_, not your own logic.

2. **Verifying too much**

   - Don’t assert every single method call. Focus only on what matters for the test.

3. **Complex setups**

   - If your mock setup is 20 lines long → maybe your class has too many dependencies.

---

## 📌 Recap

- **Moq** fakes dependencies to keep unit tests isolated.
- Use `Setup` to define return values, `Verify` to check calls.
- Match arguments with `It.IsAny<T>()` or exact values.
- Helps you test your business logic, not external services.
