# ğŸ§ª Arrangeâ€“Actâ€“Assert Pattern (AAA)

The **AAA pattern** is the most common way to structure unit tests.
It keeps your tests **clean, readable, and predictable**.

Think of it as a **3-step recipe** every test should follow:

1. **Arrange** â†’ prepare the world.
2. **Act** â†’ do the thing under test.
3. **Assert** â†’ check the outcome.

---

## ğŸ” Step-by-Step

### 1ï¸âƒ£ Arrange

- Set up everything your test needs:

  - Create objects.
  - Mock dependencies.
  - Define input data.

- Goal: put the system into the correct **starting state**.

Example:

```csharp
var repo = new Mock<IUserRepository>();
repo.Setup(r => r.GetUserById(1)).Returns(new User { Name = "Ali" });
var service = new UserService(repo.Object);
```

---

### 2ï¸âƒ£ Act

- Call the method/function you want to test.
- Just **one action per test** (ideally).
- This is the behavior we want to validate.

Example:

```csharp
var result = service.GetUser(1);
```

---

### 3ï¸âƒ£ Assert

- Check that the result is correct.
- Or verify that dependencies were called properly.
- This is where the test â€œprovesâ€ correctness.

Example:

```csharp
result.Name.Should().Be("Ali");
repo.Verify(r => r.GetUserById(1), Times.Once);
```

---

## ğŸ“Š Visual Flow

```mermaid
flowchart TD
    A[Arrange] --> B[Act] --> C[Assert]
    A -->|Set up objects, mocks, inputs| B
    B -->|Call method under test| C
    C -->|Verify outcome or interactions|
```

---

## ğŸ“– Full Example (AAA in action)

### Code under test

```csharp
public class Calculator
{
    public int Add(int a, int b) => a + b;
}
```

### Test using AAA

```csharp
[Fact]
public void Add_ShouldReturnCorrectSum()
{
    // Arrange
    var calc = new Calculator();

    // Act
    var result = calc.Add(2, 3);

    // Assert
    result.Should().Be(5);
}
```

See how **clear** it is? Anyone can glance and know:

- What we set up
- What we did
- What we expected

---

## ğŸ’¡ Why AAA matters

Without AAA, tests can get messy:

```csharp
[Fact]
public void Add_ReturnsSum()
{
    var result = new Calculator().Add(2, 3);
    Assert.Equal(5, result);
}
```

ğŸ‘‰ Works fine, but as tests grow with mocks and setups, it gets unreadable. AAA enforces **structure**.

---

## ğŸš¨ Without AAA (Bad Examples)

### Example 1 â€“ Inline everything

```csharp
[Fact]
public void Add_ReturnsSum()
{
    Assert.Equal(5, new Calculator().Add(2, 3));
}
```

ğŸ‘‰ Works, but:

- Harder to read.
- No separation between setup, action, and validation.
- Imagine adding mocks â†’ it will become spaghetti.

---

### Example 2 â€“ Mixed responsibilities

```csharp
[Fact]
public void GetUser_ReturnsCorrectUser()
{
    var repo = new Mock<IUserRepository>();
    repo.Setup(r => r.GetUserById(1)).Returns(new User { Name = "Ali" });
    var service = new UserService(repo.Object);
    var result = service.GetUser(1);
    repo.Verify(r => r.GetUserById(1), Times.Once);
    Assert.Equal("Ali", result.Name);
}
```

ğŸ‘‰ Everythingâ€™s in a block, no structure.
If this test fails later, itâ€™s harder to tell which step went wrong (setup? action? validation?).

---

## âœ… With AAA (Good Examples)

### Example 1 â€“ Simple Calculator

```csharp
[Fact]
public void Add_ShouldReturnCorrectSum()
{
    // Arrange
    var calc = new Calculator();

    // Act
    var result = calc.Add(2, 3);

    // Assert
    result.Should().Be(5);
}
```

ğŸ‘‰ Clear separation of roles:

- Setup (calc created).
- Action (Add method called).
- Assertion (check result).

---

### Example 2 â€“ With mocks

```csharp
[Fact]
public void GetUser_ShouldReturnCorrectUser()
{
    // Arrange
    var repo = new Mock<IUserRepository>();
    repo.Setup(r => r.GetUserById(1)).Returns(new User { Name = "Ali" });
    var service = new UserService(repo.Object);

    // Act
    var result = service.GetUser(1);

    // Assert
    result.Name.Should().Be("Ali");
    repo.Verify(r => r.GetUserById(1), Times.Once);
}
```

ğŸ‘‰ Each block has a **single purpose**:

- **Arrange**: define test data & mocks.
- **Act**: execute only what weâ€™re testing.
- **Assert**: check both result & interaction.

---

## ğŸ” Visual Comparison

```mermaid
flowchart TD
    subgraph Bad Test
    A1[Setup mixed inline]
    A2[Action hidden inline]
    A3[Assertion tangled]
    end

    subgraph Good Test
    B1[Arrange clearly separated]
    B2[Act clearly isolated]
    B3[Assert clearly visible]
    end

    A1 --> A2 --> A3
    B1 --> B2 --> B3
```

---

## ğŸ¯ Why AAA wins

- **Readability** â†’ anyone can scan and understand in seconds.
- **Debuggability** â†’ if a test fails, you know which block caused it.
- **Consistency** â†’ all tests look the same, easier for teams.
- **Scalability** â†’ when you add mocks/loggers/caching, AAA prevents chaos.

---

## âœ… Recap

- **Arrange**: prepare inputs and dependencies.
- **Act**: execute the function/method youâ€™re testing.
- **Assert**: check result or interaction.
- AAA makes tests **clean, repeatable, and easy to review**.
