# 🎭 NSubstitute — Mocking Made Simple in .NET

## 🤔 Why NSubstitute?

- Moq is powerful but can feel **verbose** (`mock.Setup(...).Returns(...)`).
- NSubstitute was designed to be **minimalistic, natural, and fluent**.
- Instead of `Setup` and `Verify`, it uses **direct assignment and call assertions**.

👉 In short: NSubstitute = **less ceremony, more readability.**

---

## 📦 Installing NSubstitute

Add it to your test project:

```bash
dotnet add package NSubstitute
```

Now you can substitute any interface or virtual class.

---

## 📝 Creating Substitutes

In Moq: `new Mock<IService>()`  
In NSubstitute: `Substitute.For<IService>()`

Example:

```csharp
public interface IEmailService
{
    void Send(string to, string subject, string body);
}
```

```csharp
using NSubstitute;

[Fact]
public void ShouldSendEmail()
{
    var emailService = Substitute.For<IEmailService>();

    // Act
    emailService.Send("test@example.com", "Hello", "World");

    // Assert
    emailService.Received().Send("test@example.com", "Hello", "World");
}
```

💡 Reads like plain English: _“Verify it **received** this call.”_

---

## 🧩 Returning Values

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
}
```

```csharp
[Fact]
public void ShouldReturnUser()
{
    var repo = Substitute.For<IUserRepository>();
    repo.GetUserById(1).Returns(new User { Name = "Ali" });

    var result = repo.GetUserById(1);

    result.Name.Should().Be("Ali");
}
```

💡 Just assign return values directly with `.Returns(...)`.

---

## 🔄 Argument Matching

You don’t always know the exact argument.
NSubstitute gives **argument matchers**:

```csharp
repo.GetUserById(Arg.Any<int>()).Returns(new User { Name = "Guest" });
repo.GetUserById(42).Returns(new User { Name = "Special" });
```

- `Arg.Any<T>()` → wildcard
- `Arg.Is<T>(predicate)` → match condition

Example:

```csharp
repo.GetUserById(Arg.Is<int>(id => id < 0))
    .Returns(x => throw new ArgumentException("Invalid ID"));
```

---

## 🎬 Verifying Calls

With Moq: `mock.Verify(...)`
With NSubstitute: **just ask if it was called**.

```csharp
emailService.Received(1).Send("test@example.com", "Hello", "World");
emailService.DidNotReceive().Send("spam@example.com", Arg.Any<string>(), Arg.Any<string>());
```

- `Received(n)` → check call count.
- `DidNotReceive()` → ensure no unwanted calls.

---

## ⚡ Callbacks (Capturing Parameters)

Sometimes you want to grab what was passed in.

```csharp
string? capturedBody = null;
emailService
    .When(e => e.Send("test@example.com", "Hello", Arg.Any<string>()))
    .Do(call => capturedBody = call.ArgAt<string>(2));

emailService.Send("test@example.com", "Hello", "MyMessage");

capturedBody.Should().Be("MyMessage");
```

💡 `.When(...).Do(...)` = execute code when a method is called.

---

## 🛠️ Properties

NSubstitute automatically handles properties.

```csharp
var user = Substitute.For<IUser>();
user.Name.Returns("Ali");

user.Name.Should().Be("Ali");
```

💡 No need for `SetupProperty` like in Moq.

---

## 🎁 Async Support

NSubstitute supports async tasks directly:

```csharp
public interface IAuthService
{
    Task<string> GetTokenAsync();
}

var auth = Substitute.For<IAuthService>();
auth.GetTokenAsync().Returns(Task.FromResult("fake-token"));

var token = await auth.GetTokenAsync();
token.Should().Be("fake-token");
```

---

## 🛑 Common Mistakes

1. **Forgetting `Received()`**

   ```csharp
   emailService.Send("test@example.com", "Hello", "World");
   // ❌ Test passes even if Send was not called unless you check `Received()`
   ```

2. **Overusing `Arg.Any<T>()`**

   - Makes tests too generic, reduces value.
   - Prefer `Arg.Is<T>(...)` for precision.

3. **Testing too much behavior**

   - Verifying every single call = fragile test.
   - Only assert what matters for business logic.

---

## ⚖️ Moq vs NSubstitute — Quick Comparison

| Feature            | Moq                              | NSubstitute                     |
| ------------------ | -------------------------------- | ------------------------------- |
| Create mock        | `new Mock<IService>()`           | `Substitute.For<IService>()`    |
| Get instance       | `mock.Object`                    | substitute itself               |
| Setup return value | `mock.Setup(...).Returns(...)`   | `mock.Method(...).Returns(...)` |
| Verify call        | `mock.Verify(..., Times.Once)`   | `mock.Received(1).Method(...)`  |
| Argument matching  | `It.IsAny<T>() / It.Is<T>(...)`  | `Arg.Any<T>() / Arg.Is<T>(...)` |
| Callbacks          | `mock.Setup(...).Callback(...)`  | `mock.When(...).Do(...)`        |
| Properties         | Manual `SetupProperty` sometimes | Works out of the box            |

💡 If you like **explicit setup/verify style → Moq.**
💡 If you like **minimal English-like syntax → NSubstitute.**

---

## 📌 Recap

- NSubstitute = simple, natural mocking library.
- `Substitute.For<T>()` to create a fake.
- Use `.Returns(...)` to control results.
- Use `.Received()` / `.DidNotReceive()` to verify calls.
- Supports properties, async, callbacks, and argument matchers.
- Cleaner than Moq for most scenarios.
