# ğŸ­ NSubstitute â€” Mocking Made Simple in .NET

## ğŸ¤” Why NSubstitute?

- Moq is powerful but can feel **verbose** (`mock.Setup(...).Returns(...)`).
- NSubstitute was designed to be **minimalistic, natural, and fluent**.
- Instead of `Setup` and `Verify`, it uses **direct assignment and call assertions**.

ğŸ‘‰ In short: NSubstitute = **less ceremony, more readability.**

---

## ğŸ“¦ Installing NSubstitute

Add it to your test project:

```bash
dotnet add package NSubstitute
```

Now you can substitute any interface or virtual class.

---

## ğŸ“ Creating Substitutes

In Moq: `new Mock<IService>()`  
In NSubstitute: `Substitute.For<IService>()`

Example:

```csharp
public interface IEmailService
{
    void Send(string to, string subject, string body);
}
```

```csharp
using NSubstitute;

[Fact]
public void ShouldSendEmail()
{
    var emailService = Substitute.For<IEmailService>();

    // Act
    emailService.Send("test@example.com", "Hello", "World");

    // Assert
    emailService.Received().Send("test@example.com", "Hello", "World");
}
```

ğŸ’¡ Reads like plain English: _â€œVerify it **received** this call.â€_

---

## ğŸ§© Returning Values

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
}
```

```csharp
[Fact]
public void ShouldReturnUser()
{
    var repo = Substitute.For<IUserRepository>();
    repo.GetUserById(1).Returns(new User { Name = "Ali" });

    var result = repo.GetUserById(1);

    result.Name.Should().Be("Ali");
}
```

ğŸ’¡ Just assign return values directly with `.Returns(...)`.

---

## ğŸ”„ Argument Matching

You donâ€™t always know the exact argument.
NSubstitute gives **argument matchers**:

```csharp
repo.GetUserById(Arg.Any<int>()).Returns(new User { Name = "Guest" });
repo.GetUserById(42).Returns(new User { Name = "Special" });
```

- `Arg.Any<T>()` â†’ wildcard
- `Arg.Is<T>(predicate)` â†’ match condition

Example:

```csharp
repo.GetUserById(Arg.Is<int>(id => id < 0))
    .Returns(x => throw new ArgumentException("Invalid ID"));
```

---

## ğŸ¬ Verifying Calls

With Moq: `mock.Verify(...)`
With NSubstitute: **just ask if it was called**.

```csharp
emailService.Received(1).Send("test@example.com", "Hello", "World");
emailService.DidNotReceive().Send("spam@example.com", Arg.Any<string>(), Arg.Any<string>());
```

- `Received(n)` â†’ check call count.
- `DidNotReceive()` â†’ ensure no unwanted calls.

---

## âš¡ Callbacks (Capturing Parameters)

Sometimes you want to grab what was passed in.

```csharp
string? capturedBody = null;
emailService
    .When(e => e.Send("test@example.com", "Hello", Arg.Any<string>()))
    .Do(call => capturedBody = call.ArgAt<string>(2));

emailService.Send("test@example.com", "Hello", "MyMessage");

capturedBody.Should().Be("MyMessage");
```

ğŸ’¡ `.When(...).Do(...)` = execute code when a method is called.

---

## ğŸ› ï¸ Properties

NSubstitute automatically handles properties.

```csharp
var user = Substitute.For<IUser>();
user.Name.Returns("Ali");

user.Name.Should().Be("Ali");
```

ğŸ’¡ No need for `SetupProperty` like in Moq.

---

## ğŸ Async Support

NSubstitute supports async tasks directly:

```csharp
public interface IAuthService
{
    Task<string> GetTokenAsync();
}

var auth = Substitute.For<IAuthService>();
auth.GetTokenAsync().Returns(Task.FromResult("fake-token"));

var token = await auth.GetTokenAsync();
token.Should().Be("fake-token");
```

---

## ğŸ›‘ Common Mistakes

1. **Forgetting `Received()`**

   ```csharp
   emailService.Send("test@example.com", "Hello", "World");
   // âŒ Test passes even if Send was not called unless you check `Received()`
   ```

2. **Overusing `Arg.Any<T>()`**

   - Makes tests too generic, reduces value.
   - Prefer `Arg.Is<T>(...)` for precision.

3. **Testing too much behavior**

   - Verifying every single call = fragile test.
   - Only assert what matters for business logic.

---

## âš–ï¸ Moq vs NSubstitute â€” Quick Comparison

| Feature            | Moq                              | NSubstitute                     |
| ------------------ | -------------------------------- | ------------------------------- |
| Create mock        | `new Mock<IService>()`           | `Substitute.For<IService>()`    |
| Get instance       | `mock.Object`                    | substitute itself               |
| Setup return value | `mock.Setup(...).Returns(...)`   | `mock.Method(...).Returns(...)` |
| Verify call        | `mock.Verify(..., Times.Once)`   | `mock.Received(1).Method(...)`  |
| Argument matching  | `It.IsAny<T>() / It.Is<T>(...)`  | `Arg.Any<T>() / Arg.Is<T>(...)` |
| Callbacks          | `mock.Setup(...).Callback(...)`  | `mock.When(...).Do(...)`        |
| Properties         | Manual `SetupProperty` sometimes | Works out of the box            |

ğŸ’¡ If you like **explicit setup/verify style â†’ Moq.**
ğŸ’¡ If you like **minimal English-like syntax â†’ NSubstitute.**

---

## ğŸ“Œ Recap

- NSubstitute = simple, natural mocking library.
- `Substitute.For<T>()` to create a fake.
- Use `.Returns(...)` to control results.
- Use `.Received()` / `.DidNotReceive()` to verify calls.
- Supports properties, async, callbacks, and argument matchers.
- Cleaner than Moq for most scenarios.
