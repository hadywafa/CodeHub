# âš¡ xUnit in .NET â€” The Complete Guide

## ğŸ§­ What is xUnit?

- **xUnit.net** is a free, open-source unit testing framework for .NET.
- Itâ€™s the **modern successor** of NUnit and MSTest.
- It was created by the **same people who built NUnit**, but redesigned to be cleaner, more extensible, and more community-driven.

ğŸ‘‰ In short: **xUnit is the <u title="ÙØ¹Ù„ÙŠØ§">de facto</u> standard testing framework in .NET Core / .NET 6/7/8+.**

---

## ğŸ“¦ Installing xUnit

When creating a test project, you usually do:

```bash
dotnet new xunit -n MyApp.UnitTests
dotnet sln add MyApp.UnitTests/MyApp.UnitTests.csproj
```

This gives you:

- `xunit` package
- `xunit.runner.visualstudio` â†’ allows running tests inside Visual Studio / Rider / VS Code
- `dotnet test` support

---

## ğŸ­ Core Attributes in xUnit

### 1. `[Fact]`

- Marks a method as a **unit test** with no parameters.
- Equivalent to â€œone test case.â€

```csharp
[Fact]
public void Add_ShouldReturnSum()
{
    var calc = new Calculator();
    var result = calc.Add(2, 3);
    Assert.Equal(5, result);
}
```

---

### 2. `[Theory]` and `[InlineData]`

- `[Theory]` = **data-driven test**.
- `[InlineData]` supplies test parameters.
- Each row = one test execution.

```csharp
[Theory]
[InlineData(2, 3, 5)]
[InlineData(10, -2, 8)]
[InlineData(-1, -1, -2)]
public void Add_ShouldReturnExpectedSum(int a, int b, int expected)
{
    var calc = new Calculator();
    var result = calc.Add(a, b);
    Assert.Equal(expected, result);
}
```

ğŸ’¡ With `[Theory]`, you avoid duplicating tests for similar cases.

---

### 3. `[MemberData]` & `[ClassData]`

When inputs are too complex for `[InlineData]`, use these:

```csharp
public static IEnumerable<object[]> TestData =>
    new List<object[]>
    {
        new object[] {2, 3, 5},
        new object[] {5, 5, 10},
    };

[Theory]
[MemberData(nameof(TestData))]
public void Add_WithMemberData(int a, int b, int expected)
{
    var calc = new Calculator();
    Assert.Equal(expected, calc.Add(a, b));
}
```

ğŸ’¡ Great for JSON-driven or dynamic test scenarios.

---

## ğŸ§© Assertions in xUnit (Built-in)

Before FluentAssertions, xUnit gives us:

- `Assert.Equal(expected, actual)`
- `Assert.NotEqual(expected, actual)`
- `Assert.True(condition)` / `Assert.False(condition)`
- `Assert.Null(object)` / `Assert.NotNull(object)`
- `Assert.Throws<TException>(() => ...)`
- `Assert.Contains(item, collection)`

Example (exception test):

```csharp
[Fact]
public void Divide_ByZero_ShouldThrow()
{
    var calc = new Calculator();
    Assert.Throws<DivideByZeroException>(() => calc.Divide(10, 0));
}
```

---

## âš™ï¸ Test Lifecycle in xUnit

Unlike NUnit/MSTest, **xUnit avoids attributes like `[SetUp]` and `[TearDown]`.**
Instead, it uses **constructor + `IDisposable`**:

```csharp
public class CalculatorTests : IDisposable
{
    private readonly Calculator _calc;

    public CalculatorTests()
    {
        // Runs before each test
        _calc = new Calculator();
    }

    [Fact]
    public void Add_ShouldReturnSum()
    {
        var result = _calc.Add(2, 3);
        Assert.Equal(5, result);
    }

    public void Dispose()
    {
        // Runs after each test
        // cleanup if needed
    }
}
```

---

## ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sharing Setup Across Tests

For expensive setup (like DB or API stubs), xUnit has:

1. **`IClassFixture<T>`** â†’ share setup across tests in one class.
2. **`ICollectionFixture<T>`** â†’ share setup across multiple classes.

Example:

```csharp
public class DatabaseFixture : IDisposable
{
    public DbConnection Connection { get; private set; }

    public DatabaseFixture()
    {
        Connection = new SqliteConnection("DataSource=:memory:");
        Connection.Open();
    }

    public void Dispose() => Connection.Dispose();
}

public class UserRepositoryTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;

    public UserRepositoryTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void CanInsertUser()
    {
        // use _fixture.Connection here
    }
}
```

ğŸ’¡ This prevents re-initializing heavy resources for every single test.

---

## ğŸƒ Running xUnit Tests

- CLI â†’ `dotnet test`
- Visual Studio Test Explorer â†’ green/red check marks
- Rider â†’ integrated runner
- CI/CD â†’ works out of the box with GitHub Actions / Azure Pipelines

---

## ğŸ›‘ Common xUnit Mistakes

1. **Forgetting `[Fact]` or `[Theory]`** â†’ method wonâ€™t run as test.
2. **Multiple asserts per test** â†’ harder to debug. Prefer one clear reason per test.
3. **Using shared mutable state** â†’ tests may pass locally but fail in CI.
4. **Heavy setup inside each test** â†’ slows down your test suite.

---

## ğŸ”® Why xUnit is Preferred in .NET Core

- Works naturally with `dotnet test`.
- Embraces **dependency injection** style setup (constructor injection for fixtures).
- Encourages **cleaner tests** with less boilerplate.
- Has rich ecosystem (FluentAssertions, Moq, Verify, etc. integrate smoothly).

---

## ğŸ“Œ Quick Recap

- xUnit is the standard testing framework in modern .NET.
- Use `[Fact]` for one-off tests, `[Theory]` for data-driven tests.
- Built-in `Assert` covers basics, but for better readability weâ€™ll use **FluentAssertions**.
- Lifecycle: constructor = setup, `Dispose()` = teardown.
- Fixtures help share expensive setup across tests.

---

ğŸ‘‰ Now that you have a solid foundation in **xUnit itself**, the **next natural step** is:  
â¡ï¸ **FluentAssertions** (to make the Assert step human-readable and powerful).
