# ‚úçüèª Hands-on NSubstitute

We‚Äôll use 3 scenarios you‚Äôd likely meet in real projects:

1. **Guard clause (no DB call on invalid input)**
2. **Caching (DB called only once)**
3. **Side effects (send email after saving)**

Each will use NSubstitute in a practical way.

---

## 1Ô∏è‚É£ Guard Clause Example

### Code under test

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
}

public class UserService
{
    private readonly IUserRepository _repo;
    public UserService(IUserRepository repo) => _repo = repo;

    public User? GetUser(int id)
    {
        if (id <= 0) return null;  // guard clause
        return _repo.GetUserById(id);
    }
}
```

### Unit Test with NSubstitute

```csharp
[Fact]
public void GetUser_ShouldNotCallRepository_WhenIdIsInvalid()
{
    // Arrange
    var repo = Substitute.For<IUserRepository>();
    var service = new UserService(repo);

    // Act
    var result = service.GetUser(0);

    // Assert
    result.Should().BeNull();
    repo.DidNotReceive().GetUserById(Arg.Any<int>()); // ensures repo not touched
}
```

üëâ Here, `DidNotReceive()` proves our guard clause works.

---

## 2Ô∏è‚É£ Caching Example

### Code under test

```csharp
public class CachedUserService
{
    private readonly IUserRepository _repo;
    private readonly Dictionary<int, User> _cache = new();

    public CachedUserService(IUserRepository repo) => _repo = repo;

    public User GetUser(int id)
    {
        if (!_cache.ContainsKey(id))
            _cache[id] = _repo.GetUserById(id);

        return _cache[id];
    }
}
```

### Unit Test with NSubstitute

```csharp
[Fact]
public void GetUser_ShouldOnlyCallRepoOnce_WhenCalledTwice()
{
    // Arrange
    var repo = Substitute.For<IUserRepository>();
    repo.GetUserById(1).Returns(new User { Name = "Ali" });

    var service = new CachedUserService(repo);

    // Act
    var firstCall = service.GetUser(1);
    var secondCall = service.GetUser(1);

    // Assert
    firstCall.Name.Should().Be("Ali");
    secondCall.Name.Should().Be("Ali");

    repo.Received(1).GetUserById(1); // called once only
}
```

üëâ Without `Received(1)`, you wouldn‚Äôt know if DB was called twice.

---

## 3Ô∏è‚É£ Side Effect Example (Email Sending)

### Code under test

```csharp
public interface IOrderRepository
{
    void Save(Order order);
}

public interface IEmailService
{
    void Send(string to, string subject, string body);
}

public class OrderService
{
    private readonly IOrderRepository _repo;
    private readonly IEmailService _email;

    public OrderService(IOrderRepository repo, IEmailService email)
    {
        _repo = repo;
        _email = email;
    }

    public void PlaceOrder(Order order)
    {
        _repo.Save(order);
        _email.Send(order.CustomerEmail, "Order Confirmation", "Thanks for your order!");
    }
}
```

### Unit Test with NSubstitute

```csharp
[Fact]
public void PlaceOrder_ShouldSaveOrder_AndSendEmail()
{
    // Arrange
    var repo = Substitute.For<IOrderRepository>();
    var email = Substitute.For<IEmailService>();
    var service = new OrderService(repo, email);

    var order = new Order { CustomerEmail = "customer@test.com" };

    // Act
    service.PlaceOrder(order);

    // Assert
    repo.Received(1).Save(order);
    email.Received(1).Send("customer@test.com", "Order Confirmation", "Thanks for your order!");
}
```

üëâ Here we‚Äôre not checking a return value ‚Äî we‚Äôre checking that **the right calls were made**.

---

## ‚úÖ Recap

- **Guard Clauses** ‚Üí `DidNotReceive()` is useful to prove repo wasn‚Äôt called.
- **Caching** ‚Üí `Received(1)` ensures efficiency.
- **Side Effects** ‚Üí `Received()` confirms emails/logs/notifications really happen.

> üí° NSubstitute is all about **faking dependencies** so you can test only your service logic ‚Äî no DB, no email server, no queue.
