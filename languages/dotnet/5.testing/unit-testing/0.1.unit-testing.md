# ğŸ¯ Unit Testing with xUnit â€” Beginner to Pro

## ğŸ§­ What is Unit Testing (in human words)?

A **unit test** checks a _tiny piece_ of your code (a â€œunitâ€) in isolation.  
Think: â€œGiven these inputs, I expect this exact output.â€

Example in real life:

- You have a **calculator** â†’ if you press `2 + 3`, you want `5`.
- The test is the script that checks: _does pressing `2 + 3` really give me `5`?_

Unit tests should be:

- **Fast** (milliseconds, not seconds).
- **Repeatable** (same result every run).
- **Isolated** (no DB, no API, no file system).

---

## âš™ï¸ Setting up xUnit

1. Create a test project:

   ```bash
   dotnet new xunit -n MyApp.UnitTests -o tests/MyApp.UnitTests
   dotnet sln add tests/MyApp.UnitTests/MyApp.UnitTests.csproj
   ```

2. Add `FluentAssertions` for readable assertions:

   ```bash
   dotnet add tests/MyApp.UnitTests package FluentAssertions
   ```

3. (Optional but recommended) Add `Moq` for mocking:

   ```bash
   dotnet add tests/MyApp.UnitTests package Moq
   ```

---

## ğŸ“ Writing Your First Test

Letâ€™s say we have a small **PriceCalculator** class:

```csharp
public class PriceCalculator
{
    public decimal Total(decimal price, int qty, decimal discount) =>
        Math.Max(0, price * qty - discount);
}
```

Hereâ€™s the **xUnit test**:

```csharp
using FluentAssertions;
using Xunit;

public class PriceCalculatorTests
{
    [Fact] // <- means "this is a test"
    public void Total_NeverGoesBelowZero()
    {
        // Arrange (setup)
        var sut = new PriceCalculator(); // sut = System Under Test

        // Act (do the thing)
        var total = sut.Total(price: 10m, qty: 1, discount: 20m);

        // Assert (check expectation)
        total.Should().Be(0m, "a discount cannot make totals negative");
    }
}
```

âœ… Run it with:

```bash
dotnet test
```

---

## ğŸ§ª Facts vs Theories

- `[Fact]` â†’ a single test case.
- `[Theory]` â†’ data-driven test, runs once per input row.

Example:

```csharp
public class VatCalculator
{
    public decimal AddVat(decimal net, decimal rate) => Math.Round(net * (1 + rate), 2);
}

public class VatCalculatorTests
{
    [Theory]
    [InlineData(100, 0.14, 114)]
    [InlineData(99.99, 0.14, 113.99)]
    public void AddVat_ShouldApplyCorrectly(decimal net, double rate, decimal expected)
    {
        var sut = new VatCalculator();
        sut.AddVat(net, (decimal)rate).Should().Be(expected);
    }
}
```

This avoids copy-paste: you feed multiple inputs, xUnit runs each as a separate test.

---

## ğŸ”„ Arrangeâ€“Actâ€“Assert Pattern (AAA)

This is the â€œgrammarâ€ of unit tests:

1. **Arrange**: setup the world.
2. **Act**: call the method under test.
3. **Assert**: verify outcome.

âš ï¸ Donâ€™t mix them up, and leave blank lines between sections for readability.

---

## ğŸ›‘ Common Beginner Mistakes

- **Testing too much in one test**: split into small, focused tests.
- **Relying on external systems**: unit tests shouldnâ€™t hit databases, HTTP, or files.
- **Bad naming**: use `Method_Scenario_ExpectedResult` or BDD style `Given_When_Then`.

Example:  
âœ… `Total_WhenDiscountExceedsPrice_ReturnsZero`  
âŒ `Test1`

---

## ğŸ“Œ Checklist for Unit Tests

- [ ] Uses `[Fact]` or `[Theory]` clearly
- [ ] One clear reason to fail
- [ ] AAA structure visible
- [ ] Uses `FluentAssertions` for readable asserts
- [ ] No I/O or external dependencies

---

ğŸ‘‰ Next, we can dive into **FluentAssertions** in detail (more expressive assertions) or jump to **Moq basics** (mocking dependencies).

Do you want me to expand **FluentAssertions** first (so your tests read like English), or go straight to **Moq** (so you can fake services)?
