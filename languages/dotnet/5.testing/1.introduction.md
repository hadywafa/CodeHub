# Mastering .NET Testing â€” Roadmap & Playbook

Welcome! This living guide will mentor you to mastery of testing across Console, Web API, and MVC apps using modern .NET tooling. Itâ€™s organized as a practical roadmap with code you can copyâ€‘paste, patterns to internalize, and a portfolio project plan.

---

## ðŸŽ¯ Outcomes

- Write clean, robust unit, integration, endâ€‘toâ€‘end, contract, performance, and mutation tests for .NET.
- Confidently test Console apps, ASP.NET Core Web APIs (including Minimal APIs), and MVC/Razor apps.
- Use the common libraries like `xUnit`/`NUnit`/`MSTest`, `FluentAssertions`, `Moq`/`NSubstitute`, `AutoFixture`, `Bogus`, `WireMock.Net`, `Testcontainers`, EF Core test strategies, Coverlet, Stryker.NET, Playwright, Pact.NET, and more.
- Build a CI pipeline (GitHub Actions/Azure Pipelines) that enforces quality gates (coverage, mutation score, lint) and publishes nice reports.

---

## ðŸ§± The Testing Pyramid (and Iceâ€‘Cream Cones to Avoid)

1. **Unit tests** (fast, isolated): 60â€“80%
2. **Integration tests** (slice through external boundaries): 15â€“30%
3. **E2E/UI tests** (slow, flaky if abused): 5â€“10%
4. **Contract/Consumerâ€‘Driven**: targeted, only where you integrate with other teams/services
5. **Performance/Security/Load**: periodic, automated in nightly/weeklies

> Rule of thumb: push logic downward where it can be unit tested; keep controllers/thin adapters.

---

## ðŸ§° Core Stack

- **Frameworks**: xUnit (primary), NUnit or MSTest (alternatives)
- **Assertions**: FluentAssertions
- **Test Doubles**: Moq or NSubstitute
- **Data Builders/Gen**: AutoFixture, Bogus
- **HTTP Stubs**: WireMock.Net (or RichardSzalay.MockHttp for HttpClient)
- **Containers**: Testcontainers for .NET (spawns Postgres/Redis/Kafka in tests)
- **EF Core Testing**: InMemory provider (logic only), SQLite inâ€‘memory (real relational), Respawn (DB reset)
- **Web Host Testing**: `WebApplicationFactory<TEntryPoint>` (ASP.NET Core)
- **UI/E2E**: Microsoft Playwright for .NET (preferred), Selenium only when required
- **Coverage**: Coverlet + ReportGenerator
- **Mutation Testing**: Stryker.NET
- **Contract Testing**: Pact.NET
- **Load/Perf**: k6 (CLI), BenchmarkDotNet (microbenchmarks)

---

## ðŸ—‚ï¸ Solution & Test Project Layout

```ini
/src
  MyApp.Console
  MyApp.WebApi
  MyApp.Mvc
/tests
  MyApp.UnitTests
  MyApp.IntegrationTests
  MyApp.E2ETests
  MyApp.ContractTests
  MyApp.PerfTests
```

Naming: `ProjectUnderTest.Tests` or `CategoryTests`. Keep **one test assembly per test type** for clarity and runner config.

---

## ðŸ“ Conventions: AAA & Fluent

- Use **Arrangeâ€‘Actâ€‘Assert** blocks with blank lines; prefer FluentAssertions for readable expectations.
- One **reason to fail** per test; name tests as `Method_Scenario_ExpectedBehavior` or BDD `Given_When_Then`.
- Avoid testing private methods; test behavior via public surface.

---

## 1) Unit Testing Essentials (Console/Web API/MVC)

### xUnit + FluentAssertions + Moq

```csharp
public class PriceCalculator
{
    public decimal Total(decimal price, int qty, decimal discount) =>
        Math.Max(0, price * qty - discount);
}

public class PriceCalculatorTests
{
    [Fact]
    public void Total_WithDiscount_DoesNotGoBelowZero()
    {
        // Arrange
        var sut = new PriceCalculator();

        // Act
        var total = sut.Total(price: 10m, qty: 1, discount: 20m);

        // Assert
        total.Should().Be(0m);
    }
}
```

### Dataâ€‘Driven Tests with Theories

```csharp
public class VatCalculator
{
    public decimal AddVat(decimal net, decimal rate) => Math.Round(net * (1 + rate), 2);
}

public class VatCalculatorTests
{
    [Theory]
    [InlineData(100, 0.14, 114)]
    [InlineData(99.99, 0.14, 113.99)]
    public void AddVat_WorksForCommonRates(decimal net, double rate, decimal expected)
    {
        var sut = new VatCalculator();
        sut.AddVat(net, (decimal)rate).Should().Be(expected);
    }
}
```

### AutoFixture + Bogus (Generating Realistic Data)

```csharp
var fixture = new Fixture();
var order = fixture.Build<Order>()
    .With(o => o.Items, new Faker<OrderItem>()
        .RuleFor(i => i.Sku, f => f.Commerce.Ean13())
        .RuleFor(i => i.Price, f => f.Finance.Amount(1, 100))
        .Generate(3))
    .Create();
```

### Moq Basics (Stubs & Verifications)

```csharp
public interface ICurrencyRates { decimal GetUsdToEgp(); }
public class FxService { public decimal ConvertToEgp(decimal usd, ICurrencyRates r) => usd * r.GetUsdToEgp(); }

[Fact]
public void ConvertToEgp_UsesRatesService()
{
    var rates = new Mock<ICurrencyRates>();
    rates.Setup(r => r.GetUsdToEgp()).Returns(50m);

    var sut = new FxService();
    sut.ConvertToEgp(2m, rates.Object).Should().Be(100m);

    rates.Verify(r => r.GetUsdToEgp(), Times.Once);
}
```

> **Tip:** Prefer injecting abstractions. For `HttpClient`, inject a named client or `HttpMessageHandler` to mock.

---

## 2) Integration Tests (ASP.NET Core & EF Core)

### Minimal API with `WebApplicationFactory`

```csharp
// Program.cs
var app = WebApplication.CreateBuilder(args).Build();
app.MapGet("/hello", () => Results.Ok(new { message = "hi" }));
app.Run();

// Test
public class HelloApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public HelloApiTests(WebApplicationFactory<Program> factory) => _client = factory.CreateClient();

    [Fact]
    public async Task Hello_ReturnsOk()
    {
        var res = await _client.GetAsync("/hello");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        var body = await res.Content.ReadFromJsonAsync<dynamic>();
        ((string)body.message).Should().Be("hi");
    }
}
```

### Swapping Services for Tests

Use a custom factory to replace real services (e.g., external HTTP, DB) with fakes.

```csharp
public class TestWebAppFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            // Replace real IEmailSender with fake
            services.RemoveAll<IEmailSender>();
            services.AddSingleton<IEmailSender, FakeEmailSender>();
        });
    }
}
```

### EF Core: Choose the Right Strategy

- **InMemory provider**: fast, but NOT relational; good for domain logic only.
- **SQLite inâ€‘memory**: lightweight, relational (constraints, transactions). Use migrations.
- **Testcontainers**: spin a real Postgres/SQL Server per test class for highest fidelity.

```csharp
// SQLite in-memory example
services.AddDbContext<AppDb>(o => o.UseSqlite("DataSource=:memory:"));
```

### Database Reset Between Tests

- **Respawn** to wipe tables between tests.

```csharp
var respawner = await Respawner.CreateAsync(conn, new RespawnerOptions { DbAdapter = DbAdapter.SqlServer });
await respawner.ResetAsync(conn);
```

### Stubbing External HTTP: WireMock.Net

```csharp
var server = WireMockServer.Start();
server.Given(Request.Create().WithPath("/rates").UsingGet())
      .RespondWith(Response.Create().WithStatusCode(200).WithBody("{ \"usdToEgp\": 50 }"));

var client = new HttpClient { BaseAddress = new Uri(server.Urls[0]) };
```

### Real Dependencies via Testcontainers

```csharp
var pg = new PostgreSqlBuilder().WithImage("postgres:16").Build();
await pg.StartAsync();
// point EF Core connection string to pg.GetConnectionString()
```

---

## 3) MVC & UI/E2E Tests (Playwright)

### Smoke Test an MVC App

```csharp
[Fact]
public async Task Home_Index_ShowsTitle()
{
    await using var pw = await Playwright.CreateAsync();
    var browser = await pw.Chromium.LaunchAsync(new() { Headless = true });
    var page = await browser.NewPageAsync();
    await page.GotoAsync("https://localhost:5001/");
    (await page.TitleAsync()).Should().Contain("Home");
}
```

> Use `Microsoft.Playwright.NUnit` or xUnit fixtures to start the app before tests. Prefer **dataâ€‘testid** attributes in your views for stable selectors.

---

## 4) Contract Testing (Pact.NET)

Ensure your Web API honors contracts with consumers.

```csharp
var pact = Pact.V3("Consumer", "Provider", new PactConfig());
// define interactions, generate pact file; provider verifies in CI against pacts
```

---

## 5) Performance & Load

- **BenchmarkDotNet** for microbenchmarks on hot code paths.
- **k6** scripts for API load tests; run in CI nightly and chart trends.

---

## 6) Snapshot/Approval Testing

- **Verify** or **Snapshooter** to snapshot complex JSON/HTML and diff on change.

```csharp
await Verify(jsonObject);
```

---

## 7) Coverage & Mutation Quality Gates

### Coverage

- Add Coverlet and ReportGenerator; publish HTML in CI.

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutput=./coverage/ /p:MergeWith="./coverage/coverage.json" /p:CoverletOutputFormat=cobertura
reportgenerator -reports:coverage/coverage.cobertura.xml -targetdir:coverage-report
```

### Mutation (Stryker.NET)

```bash
dotnet tool install -g dotnet-stryker
stryker --solution MyApp.sln --reporter html
```

> Aim for **mutation score > 70%** on core libraries.

---

## 8) CI: GitHub Actions (sample)

```yaml
name: tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: "9.0.x" }
      - run: dotnet restore
      - run: dotnet build --configuration Release --no-restore
      - run: dotnet test --configuration Release --collect:"XPlat Code Coverage" --logger trx --results-directory test-results
      - name: ReportGenerator
        run: |
          dotnet tool update -g dotnet-reportgenerator-globaltool
          reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage-report
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        with: { name: coverage-html, path: coverage-report }
```

---

## 9) Redâ€‘Greenâ€‘Refactor: TDD Cadence & Heuristics

- Start with **outsideâ€‘in** for Web API: write failing requestâ€‘level test (integration) â†’ drive controller â†’ service â†’ domain (unit tests).
- Keep tests **deterministic**. Control randomness, time (`ITimeProvider`), and environment (config) via DI.
- Parallelize unit tests; serialize integration tests that share state.

---

## ðŸ” Checklists

### Unit Test Checklist

- [ ] Clear Arrange/Act/Assert
- [ ] Single expectation (or cohesive group)
- [ ] No real I/O, network, or time dependencies
- [ ] Uses FluentAssertions with helpful messages

### Integration Test Checklist

- [ ] Uses `WebApplicationFactory` or hosted test server
- [ ] Stable data seeding/reset (Respawn/Migrations)
- [ ] External HTTP stubbed (WireMock) or real dep via Testcontainers
- [ ] Idempotent and parallelâ€‘safe where possible

### E2E/UI Checklist

- [ ] Stable selectors (dataâ€‘testid)
- [ ] Retry/wait strategy only where needed
- [ ] Screenshots on failure

---

## ðŸ§ª Portfolio Project (Endâ€‘toâ€‘End)

Build **ShopRight**: a small store with Console job (ETL), Web API (catalog/orders), and MVC frontend.

- Unitâ€‘test domain: pricing, discounts, inventory
- Integrationâ€‘test API endpoints with SQLite/Testcontainers
- Contractâ€‘test between MVC (consumer) and API (provider) via Pact
- E2E with Playwright: happy paths for browse â†’ add to cart â†’ checkout
- CI gates: coverage â‰¥ 80%, mutation â‰¥ 60%, flaky test guard

---

## ðŸ“š Quick Reference (Libraries & NuGet)

- xUnit: `dotnet add package xunit --version *`
- FluentAssertions: `dotnet add package FluentAssertions`
- Moq: `dotnet add package Moq`
- AutoFixture: `dotnet add package AutoFixture`
- Bogus: `dotnet add package Bogus`
- WireMock.Net: `dotnet add package WireMock.Net.StandAlone`
- Testcontainers: `dotnet add package Testcontainers`
- Respawn: `dotnet add package Respawn`
- Microsoft.AspNetCore.Mvc.Testing: `dotnet add package Microsoft.AspNetCore.Mvc.Testing`
- Playwright: `dotnet add package Microsoft.Playwright`
- Verify: `dotnet add package Verify.Xunit`
- Coverlet: `dotnet add package coverlet.collector`
- ReportGenerator: `dotnet tool install -g dotnet-reportgenerator-globaltool`
- Stryker.NET: `dotnet tool install -g dotnet-stryker`
- Pact.NET: `dotnet add package PactNet`

---

## ðŸ—“ï¸ 4â€‘Week Mentored Plan

**Week 1:** Unit testing mastery (xUnit, FluentAssertions, Moq, AutoFixture); refactor legacy code seams.

**Week 2:** Integration testing (WebApplicationFactory, EF Core SQLite vs Testcontainers, WireMock, Respawn). Build API test suite.

**Week 3:** MVC/E2E via Playwright; add snapshot tests and contract tests (Pact).

**Week 4:** Quality gates (Coverlet, Stryker), CI pipelines, flaky test hunting, performance smoke with k6/BenchmarkDotNet.

> Weâ€™ll iterate here with exercises and code reviews. Add questions or topics you want expanded next!
