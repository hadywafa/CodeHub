# ğŸ› ï¸ **Deep Dive into the WiredTiger Storage Engine** â€“ The Brain of MongoDB! ğŸš€

WiredTiger is **MongoDBâ€™s default storage engine** and is also used in AWS DocumentDB. Unlike SQL databases, which rely on **B-Trees**, WiredTiger is designed for **high-concurrency, compression, and fast performance using a Log-Structured Merge Tree (LSM) and B+ Trees**.

This deep dive covers:
1ï¸âƒ£ **How WiredTiger Works** ğŸ› ï¸  
2ï¸âƒ£ **How Data is Stored on Disk** ğŸ’¾  
3ï¸âƒ£ **How Data is Retrieved** ğŸ”  
4ï¸âƒ£ **Detailed Sequence Diagram for Disk Reads** ğŸ–¼ï¸

---

# ğŸ› ï¸ **1ï¸âƒ£ How WiredTiger Works â€“ The High-Level View**

### ğŸ”¥ **Core Features of WiredTiger**

âœ… **Uses a Combination of B+ Trees & LSM Trees** for indexing and storage.  
âœ… **Supports Multi-Version Concurrency Control (MVCC)** for high concurrency reads/writes.  
âœ… **Uses Write-Ahead Logging (WAL)** to ensure durability.  
âœ… **Compresses Data Efficiently** using Snappy/Zlib compression.  
âœ… **Supports Memory-Mapped Files (MMAP)** to speed up access.

---

# ğŸ’¾ **2ï¸âƒ£ How Data is Stored on Disk in WiredTiger**

## ğŸ—ï¸ **Storage Components**

WiredTiger organizes data using **Table, Data Files, and Checkpoints**.

### ğŸ“‚ **Storage Breakdown:**

| Component                               | Description                                                              |
| --------------------------------------- | ------------------------------------------------------------------------ |
| **Collection Table**                    | Each MongoDB collection is stored as a separate **table** in WiredTiger. |
| **B-Trees & LSM Trees**                 | Used for indexing and efficient data retrieval.                          |
| **Data Files (`.wt`)**                  | Each collection is stored in a `.wt` file (e.g., `collection-2.wt`).     |
| **Write-Ahead Log (`WiredTigerLog.*`)** | Used for durability and crash recovery.                                  |
| **Metadata (`WiredTiger.wt`)**          | Stores metadata about collections, indexes, and transactions.            |

### ğŸ“‚ **File Structure Example (Inside MongoDB Data Directory)**

```
/data/db/
  â”œâ”€â”€ WiredTiger.wt                # Metadata for all tables
  â”œâ”€â”€ WiredTigerLog.0000000001      # Write-Ahead Log
  â”œâ”€â”€ collection-2-1123456789.wt    # Collection Data File
  â”œâ”€â”€ index-3-1123456789.wt         # Index Data File
```

ğŸ“Œ **Each `.wt` file is a self-contained table stored in B-Trees or LSM Trees!**  
ğŸ“Œ **Indexes are also stored in `.wt` files separately for faster lookups.**

---

# ğŸ” **3ï¸âƒ£ How Data is Retrieved from Disk (Read Workflow)**

Now, letâ€™s break down how **MongoDB fetches a document from WiredTiger** when a user executes:

```json
db.users.findOne({ "name": "Ahmed" })
```

### **ğŸ› ï¸ Step-by-Step Read Process**

1ï¸âƒ£ **Query Parser:** The query is received and parsed.  
2ï¸âƒ£ **Query Planner:** The best index (if available) is selected.  
3ï¸âƒ£ **Index Lookup:** WiredTiger fetches the index from the `.wt` file.  
4ï¸âƒ£ **Document Lookup:** If found in the index, WiredTiger fetches the actual document from disk.  
5ï¸âƒ£ **Cache Check:** If data is frequently accessed, it's served from **WiredTigerâ€™s in-memory cache** instead of disk.  
6ï¸âƒ£ **Return Data:** The document is sent back to the user.

---

# ğŸ–¼ï¸ **4ï¸âƒ£ Sequence Diagram â€“ How WiredTiger Retrieves Data from Disk**

Hereâ€™s a **Mermaid Sequence Diagram** to visualize the data retrieval process! ğŸ¯

```mermaid
sequenceDiagram
    participant User as User
    participant MongoDB as MongoDB Query Engine
    participant WiredTiger as WiredTiger Storage Engine
    participant Disk as Disk Storage

    User->>MongoDB: db.users.findOne({ "name": "Ahmed" })
    MongoDB->>WiredTiger: Parse query & check index
    WiredTiger-->>MongoDB: Index found (User ID: 123)

    MongoDB->>WiredTiger: Fetch document with ID 123
    alt Data in WiredTiger Cache?
        WiredTiger-->>MongoDB: Serve document from Cache
    else Data not in Cache
        WiredTiger->>Disk: Read data from `collection-2.wt`
        Disk-->>WiredTiger: Return BSON document
        WiredTiger-->>MongoDB: Serve document
    end

    MongoDB-->>User: Return JSON Document
```

ğŸ“Œ **Key Takeaways from the Sequence Diagram:**

- MongoDB first **checks indexes** before scanning the collection.
- WiredTiger **caches** frequently accessed data to avoid disk reads.
- If data is **not in cache**, itâ€™s read from the `.wt` file on **disk**.
- **BSON format** is read from disk and returned as **JSON** to the user.

---

# ğŸ¯ **5ï¸âƒ£ Optimizations & Performance Features in WiredTiger**

WiredTiger **optimizes performance** using:

### ğŸš€ **1. WiredTiger Cache**

- Stores frequently accessed documents **in memory**.
- Avoids expensive disk reads.
- By default, **uses 50% of available RAM**.

### ğŸ“Š **2. Write-Ahead Logging (WAL)**

- Writes are first logged to `WiredTigerLog` before committing.
- Ensures **data durability** (prevents corruption on crashes).

### ğŸ“ˆ **3. Compression for Disk Efficiency**

- Uses **Snappy or Zlib compression** to reduce storage size.
- Faster reads due to **smaller data blocks**.

### ğŸ”„ **4. Multi-Version Concurrency Control (MVCC)**

- Allows **simultaneous reads & writes** without locking.
- Each user sees a **consistent snapshot** of data.

---

# ğŸ **Final Thoughts**

ğŸ”¥ **WiredTiger is a powerful storage engine designed for speed and scalability.**  
âœ… **Uses B-Trees & LSM Trees for efficient indexing.**  
âœ… **Leverages in-memory caching to avoid disk reads.**  
âœ… **Uses Write-Ahead Logging (WAL) for durability.**  
âœ… **Optimized for concurrent access with MVCC.**

ğŸ’¡ **Next Topic?** Do you want a deep dive into **how WiredTiger handles writes & journaling? ğŸš€ğŸ”¥**
