# ğŸ§µ **Thread Safety and Locks in C# (`lock`, `Monitor`, `Mutex`)**

> Safeguard your data in a multithreaded world ğŸ§ 

---

## ğŸ§  What Is Thread Safety?

> Thread safety means your code can be **safely accessed by multiple threads at the same time** without corrupting state.

---

### ğŸ§¨ Example of Unsafe Code

```csharp
int counter = 0;

void Increment()
{
    for (int i = 0; i < 1000; i++)
        counter++; // âŒ Not thread-safe!
}
```

> Multiple threads might update `counter` at the same time â†’ ğŸ’¥ race condition â†’ wrong result!

---

## ğŸ” 1. `lock` Statement â€” The Most Common Tool

```csharp
private readonly object _lock = new();

void Increment()
{
    lock (_lock)
    {
        counter++; // âœ… Thread-safe now!
    }
}
```

âœ… `lock` ensures that **only one thread at a time** can enter that critical section

---

## ğŸ“¦ 2. `Monitor` Class (Behind the Scenes of `lock`)

```csharp
Monitor.Enter(_lock);
try
{
    counter++; // same as lock block
}
finally
{
    Monitor.Exit(_lock);
}
```

> âœ… Gives you more control (e.g., timeout, try-enter)

---

## ğŸ” 3. `Mutex` â€“ Cross-Process Locking

> Use `Mutex` when you want to **synchronize access across multiple processes**

```csharp
using var mutex = new Mutex(false, "Global\\MyAppLock");

if (mutex.WaitOne())
{
    // Do something safely
    mutex.ReleaseMutex();
}
```

> âœ… Slower than `lock`, but works across app domains or OS processes

---

## âš™ï¸ 4. Other Synchronization Tools

| Tool                   | Description                             |
| ---------------------- | --------------------------------------- |
| `lock`                 | Easiest way to make a block thread-safe |
| `Monitor`              | More flexible (`TryEnter`, timeouts)    |
| `Mutex`                | For cross-process locking               |
| `Semaphore`            | Allows limited number of threads in     |
| `ReaderWriterLockSlim` | Allows multiple readers, single writer  |

---

## âš ï¸ Avoid These Mistakes

| Mistake                                     | Why It's Dangerous                       |
| ------------------------------------------- | ---------------------------------------- |
| Locking on `this`                           | Exposes internal lock to others          |
| Deadlocks                                   | When threads wait forever for each other |
| Nested locks (lock A then B, lock B then A) | Can easily cause deadlocks               |
| Forgetting `Monitor.Exit()`                 | Causes permanent lock ğŸ”’                 |

---

## ğŸ’¬ Interview Insight

> "Locking is essential in multi-threaded apps. Use `lock` for in-process sync and `Mutex` for cross-process. Always avoid deadlocks and lock on private objects, not `this` or public ones."

---

## âœ… Summary Table

| Feature      | Use Case                            | Scope             | Performance  |
| ------------ | ----------------------------------- | ----------------- | ------------ |
| `lock`       | In-process critical sections        | Fastest, simplest | ğŸŸ¢ Fast      |
| `Monitor`    | Fine-grained locking                | In-process        | ğŸŸ¢ Fast      |
| `Mutex`      | Cross-process locking               | OS-wide           | ğŸ”´ Slower    |
| `Semaphore`  | Limited concurrency (e.g., 3 users) | In-process or OS  | ğŸŸ¡ Medium    |
| `RWLockSlim` | Many readers, one writer            | In-process        | ğŸŸ¢ Very Fast |

---

## ğŸ§  Real-World Analogy

| Tool        | Analogy                                    |
| ----------- | ------------------------------------------ |
| `lock`      | Locking a door while using the bathroom ğŸšª |
| `Monitor`   | Same door but with extra keys or rules ğŸ”  |
| `Mutex`     | Global lock shared between apartments ğŸ¢   |
| `Semaphore` | Only 3 people allowed in the elevator ğŸš¶â€â™‚ï¸ğŸš¶â€â™€ï¸ |
