# **Composition vs. Inheritance in C#**

> Why great devs often say: â€œ**Favor composition over inheritance**â€ ðŸ§ 

---

## ðŸ§  What Is Composition?

> **Composition** means **building objects by combining** other objects that **provide specific behavior**.

Rather than saying:

> â€œA `Car` **is a kind of** Vehicleâ€ (inheritance),
> Composition says:
> â€œA `Car` **has a** Engine, Wheel, GPS, etc.â€

---

## ðŸŽ¯ Inheritance vs Composition â€“ Quick Contrast

| Feature        | Inheritance                       | Composition                      |
| -------------- | --------------------------------- | -------------------------------- |
| Relationship   | `is-a`                            | `has-a`                          |
| Reuse style    | Reuse code via base class         | Reuse code via contained objects |
| Flexibility    | Tight coupling                    | Loose, replaceable parts         |
| Example        | `class Dog : Animal`              | `class Car { Engine engine; }`   |
| Preferred when | Hierarchy is **stable and rigid** | Behavior needs **flexibility**   |

---

## ðŸ” Inheritance Example (Tightly Coupled)

```csharp
class Animal
{
    public virtual void MakeSound() => Console.WriteLine("Sound");
}

class Dog : Animal
{
    public override void MakeSound() => Console.WriteLine("Bark");
}
```

> âœ… Good if behavior **never changes**
> âŒ Hard to change base class without affecting all derived ones

---

## ðŸ§© Composition Example (More Flexible)

```csharp
public interface ISoundBehavior
{
    void MakeSound();
}

public class BarkSound : ISoundBehavior
{
    public void MakeSound() => Console.WriteLine("Bark!");
}

public class Dog
{
    private ISoundBehavior _sound;

    public Dog(ISoundBehavior sound)
    {
        _sound = sound;
    }

    public void MakeSound() => _sound.MakeSound();
}
```

### Usage

```csharp
var dog = new Dog(new BarkSound());
dog.MakeSound(); // ðŸ‘‰ Bark!
```

> ðŸ’¡ Now `Dog` can easily bark, meow, or sing â€” just by injecting a different behavior object!

---

## ðŸ§° Real-World Analogy

| Concept     | Inheritance                        | Composition                                  |
| ----------- | ---------------------------------- | -------------------------------------------- |
| Car Design  | All cars inherit the same features | Each car **has** a custom engine, seats, GPS |
| Food Orders | All orders are a `BaseOrder` class | Each order **has** toppings, packaging, etc. |

---

## ðŸ’Ž When to Use What?

| Use Inheritance When...           | Use Composition When...                     |
| --------------------------------- | ------------------------------------------- |
| Thereâ€™s a clear, stable hierarchy | Behavior needs to vary at runtime           |
| Subclass IS-A base class          | You want flexibility and unit testing       |
| All subclasses share base logic   | You want reusable, pluggable functionality  |
| You're okay with tight coupling   | You prefer modular, changeable architecture |

---

## ðŸ§  Interview Insight

> "While inheritance is powerful, it tightly couples your design. In modern C#, we favor **composition**, **interfaces**, and **dependency injection** to create **flexible, testable**, and **extensible** systems."

---

## âœ… Summary Table

| Concept     | Inheritance                   | Composition                           |
| ----------- | ----------------------------- | ------------------------------------- |
| Code Reuse  | Via base class                | Via member objects                    |
| Flexibility | Low                           | High                                  |
| Coupling    | Tight                         | Loose                                 |
| Real Use    | Shape hierarchies, frameworks | Services, behaviors, strategy pattern |
| OOP Motto   | "is-a"                        | "has-a"                               |

---

## ðŸ§ª Bonus: Strategy Pattern = Composition in Action

Youâ€™ve already seen it:

```csharp
class Duck
{
    private IFlyBehavior _fly;
    public Duck(IFlyBehavior fly) => _fly = fly;
    public void Fly() => _fly.Fly();
}
```

âœ… You swap `FlyWithWings`, `FlyNoWay`, `FlyRocketPower` without changing the Duck class.
This is the **Strategy Pattern**, a real-world example of **composition** over inheritance.
