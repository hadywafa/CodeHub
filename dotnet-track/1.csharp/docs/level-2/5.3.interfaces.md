# ðŸ”Œ **Interfaces in C#**

> `interface`, implementation, and polymorphism â€” clean and contract-based design ðŸ§©

---

## ðŸ§  What Is an Interface?

> An **interface** is a **contract**.
> It defines **what a class must do**, but **not how** it does it.

In C#, an interface:

- Has **no implementation**
- Only contains **method signatures**, **properties**, **events**, or **indexers**
- Is implemented using the `: interfaceName` syntax

---

## ðŸ§© Basic Syntax

```csharp
public interface IAnimal
{
    void Speak();
}
```

```csharp
public class Dog : IAnimal
{
    public void Speak()
    {
        Console.WriteLine("Woof!");
    }
}
```

> âœ… Classes use `:` to **implement** interfaces
> âŒ Interfaces **canâ€™t have fields or constructors**

---

## ðŸ›  Interface Members

| Can Have?    | Allowed in Interface |
| ------------ | -------------------- |
| Methods      | âœ… Yes               |
| Properties   | âœ… Yes               |
| Indexers     | âœ… Yes               |
| Events       | âœ… Yes               |
| Fields       | âŒ No                |
| Constructors | âŒ No                |

---

## ðŸ§ª Real-World Example

```csharp
public interface ILogger
{
    void Log(string message);
}
```

```csharp
public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[Console] {message}");
    }
}
```

Usage:

```csharp
ILogger logger = new ConsoleLogger();
logger.Log("Hello");
```

> ðŸŽ¯ We program to the **interface**, not to the implementation. This gives us **polymorphism**, **flexibility**, and **testability**.

---

## ðŸ§  Why Use Interfaces?

| Reason               | Benefit                       |
| -------------------- | ----------------------------- |
| Abstraction          | Hide implementation details   |
| Loose coupling       | Replace components easily     |
| Dependency Injection | Swap real vs. fake services   |
| Testability          | Mock interfaces in unit tests |
| Multiple inheritance | Implement multiple interfaces |

---

## ðŸ“š Interface vs Abstract Class

| Feature        | Interface               | Abstract Class         |
| -------------- | ----------------------- | ---------------------- |
| Inheritance    | Multiple allowed        | Only one               |
| Can have code  | âŒ (until C# 8 default) | âœ… Yes                 |
| Constructors   | âŒ No                   | âœ… Yes                 |
| Fields allowed | âŒ No                   | âœ… Yes                 |
| Use when...    | Contracts only          | Base logic + extension |

---

## ðŸ§± Multiple Interface Implementation

```csharp
public interface IReadable { void Read(); }
public interface IWritable { void Write(); }

public class FileHandler : IReadable, IWritable
{
    public void Read() { Console.WriteLine("Reading"); }
    public void Write() { Console.WriteLine("Writing"); }
}
```

---

## âš ï¸ Explicit Interface Implementation

Used when:

- You want to **hide interface methods** from public API
- Or when **multiple interfaces have same method name**

```csharp
public interface IReader { void Read(); }
public interface IWriter { void Read(); }

public class Device : IReader, IWriter
{
    void IReader.Read() => Console.WriteLine("Reader Read()");
    void IWriter.Read() => Console.WriteLine("Writer Read()");
}
```

Usage:

```csharp
IReader r = new Device();
r.Read(); // Calls IReader's Read

IWriter w = new Device();
w.Read(); // Calls IWriter's Read
```

---

## ðŸ’¬ Interview Insight

> "Interfaces enable flexible, testable, and loosely coupled architectures. In clean architecture or domain-driven design, most services and repositories should be coded against interfaces to maximize composability and mockability."

---

## âœ… Summary Table

| Concept             | Example                    | Use Case                         |
| ------------------- | -------------------------- | -------------------------------- |
| Define Interface    | `interface IShape {}`      | Describe capabilities            |
| Implement Interface | `class Circle : IShape`    | Provide behavior                 |
| Explicit Impl.      | `IShape.Draw()`            | Disambiguate or hide methods     |
| Polymorphism        | `IShape s = new Circle();` | Reuse code across multiple types |
