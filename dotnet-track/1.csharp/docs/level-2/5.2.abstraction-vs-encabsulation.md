# ğŸ­ **Encapsulation vs. Abstraction in C#**

> What's the difference? When to use each? Are they the same? (Nope!) ğŸ¤¯

---

## ğŸ§  TL;DR Summary

| Feature        | Encapsulation ğŸ”                       | Abstraction ğŸ§                      |
| -------------- | -------------------------------------- | ---------------------------------- |
| **Goal**       | **Hide internal data/implementation**  | **Hide unnecessary complexity**    |
| **Focus**      | **How it's accessed**                  | **What is exposed**                |
| **Implements** | Access modifiers (`private`, `public`) | Abstract classes, interfaces       |
| **Protects**   | Data integrity                         | Design clarity                     |
| **Real-world** | ATM: You canâ€™t see internal cash box   | ATM: You only see buttons & screen |

---

## ğŸ” What is Encapsulation?

> Encapsulation is **data hiding** â€” restricting access to internal data by wrapping it with controlled access (via properties and methods).

### ğŸ”§ Implementation

- Private fields
- Public/protected properties
- Access modifiers (private/protected/internal)

### ğŸ§± Example

```csharp
class BankAccount
{
    private decimal _balance;

    public decimal Balance => _balance;

    public void Deposit(decimal amount)
    {
        if (amount <= 0) throw new Exception("Invalid amount");
        _balance += amount;
    }
}
```

âœ… You **canâ€™t set `_balance` directly**. You must go through **controlled methods**.

---

## ğŸ§  What is Abstraction?

> Abstraction is about **exposing only relevant behavior** â€” hiding all the implementation details behind an interface or abstract class.

### ğŸ”§ Implementation

- Interfaces
- Abstract classes
- Base class + overridden methods

### ğŸ§± Example

```csharp
interface IPaymentService
{
    void Pay();
}

class PayPal : IPaymentService
{
    public void Pay()
    {
        // internal API calls, tokens, etc. (hidden)
        Console.WriteLine("Paying with PayPal");
    }
}
```

âœ… You **only know about the `Pay()` method** â€” no idea how it works internally. Thatâ€™s **abstraction**.

---

## ğŸ” Key Differences

| Aspect               | Encapsulation ğŸ”                           | Abstraction ğŸ§                              |
| -------------------- | ------------------------------------------ | ------------------------------------------ |
| **What it hides**    | The **data and implementation details**    | The **complexity / how things work**       |
| **What it shows**    | Controlled access to internal logic        | Only the methods/features needed           |
| **Primary tool**     | `private`, `public`, `get`, `set`          | `interface`, `abstract class`, `virtual`   |
| **Focus**            | **Security & Integrity** of data           | **Simplicity & Generalization**            |
| **Use Case**         | Protect fields in classes                  | Define shared behavior across systems      |
| **Can exist alone?** | âœ… Always (every class should encapsulate) | âš ï¸ Optional â€” abstraction only when needed |

---

## ğŸ” Encapsulation Analogy

> Think of a **capsule** (pill): You get the medicine (behavior), but you donâ€™t see the **chemistry inside** (implementation).
> You take it â€” it works. You donâ€™t care **how**.

---

## ğŸ§  Abstraction Analogy

> Think of using a **TV remote**:
> You press "Volume Up" â€” you donâ€™t care **how signals are sent**, **how circuits interpret it**, or **how the screen updates**.
> You just use the **interface**.

---

## ğŸ“ Interview Insight

> â€œEncapsulation is about **how you protect internal state**, while abstraction is about **how you expose a clean, usable interface**. You encapsulate to _hide data_, and abstract to _hide complexity_.â€

---

## âœ… Summary Table

| Feature          | Encapsulation ğŸ”            | Abstraction ğŸ§                |
| ---------------- | --------------------------- | ---------------------------- |
| Primary Use      | Protect data                | Hide complexity              |
| Used With        | Classes, fields, properties | Abstract classes, interfaces |
| Accessed Through | Getters/setters             | Contracts/interfaces         |
| Visible Behavior | Selectively exposed         | Public interface only        |
| Helps With       | Data integrity              | System design                |

---

## ğŸ¤ How They Work Together

ğŸ”„ **Every class you abstract should encapsulate.**
You can:

- Abstract using `interface ICar`
- Implement it with class `Car`, which **encapsulates internal state**

```csharp
public interface ICar
{
    void Drive();
}

public class Tesla : ICar
{
    private int batteryLevel = 100;

    public void Drive()
    {
        batteryLevel -= 10;
        Console.WriteLine("Vroom... battery now " + batteryLevel);
    }
}
```

Here:

- `ICar` â†’ **Abstraction** (only shows `Drive()`)
- `batteryLevel` â†’ **Encapsulation** (hidden state)
