# ðŸ” **Polymorphism in C#**

> `virtual`, `override`, `abstract`, and `new` â€” Mastering behavior at runtime ðŸ”¥

---

## ðŸ§  What Is Polymorphism?

> **Polymorphism** means â€œ**many forms**.â€
> In C#, it lets you call the **same method** on **different objects**, and get **different behavior** based on the objectâ€™s actual type.

### ðŸ¤” Why care?

It helps you:

- ðŸ§¼ Write **flexible**, **extensible** code
- ðŸ’¡ Use base classes and interfaces to abstract logic
- ðŸ§ª Apply the **Open/Closed Principle** (O in SOLID)

---

## ðŸŽ­ Example: Same Method, Different Behavior

```csharp
class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("Animal speaks");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Dog barks");
    }
}

class Cat : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Cat meows");
    }
}
```

```csharp
Animal a1 = new Dog();
Animal a2 = new Cat();

a1.Speak(); // Dog barks ðŸ¶
a2.Speak(); // Cat meows ðŸ±
```

> ðŸ”¥ This is **runtime polymorphism** using `virtual` and `override`

---

## ðŸ§± 1. `virtual` â€“ Allow Overriding

Mark the base class method as `virtual` to let child classes **override** it.

```csharp
public virtual void Speak() { ... }
```

---

## ðŸ§± 2. `override` â€“ Change Base Behavior

In the derived class, use `override` to **replace** base logic:

```csharp
public override void Speak() { ... }
```

---

## ðŸ§± 3. `abstract` â€“ Force Override (No Default)

Used when base class has **no meaningful implementation**, and you want to **force derived classes** to implement it.

```csharp
abstract class Shape
{
    public abstract void Draw(); // No body
}

class Circle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Drawing circle");
    }
}
```

> ðŸ§  `abstract` methods must be inside an `abstract` class
> âŒ You **canâ€™t instantiate** abstract classes

---

## ðŸ”’ Abstract Class vs Interface (Quick Glance)

| Feature                | Abstract Class   | Interface                       |
| ---------------------- | ---------------- | ------------------------------- |
| Can have fields?       | âœ… Yes           | âŒ No (until C# 8 default impl) |
| Method implementation? | âœ… Optional      | âŒ Until C# 8                   |
| Inheritance            | Single only      | Multiple allowed                |
| Use case               | Partial behavior | Full abstraction                |

---

## ðŸ§± 4. `new` Keyword â€“ Hide Instead of Override

> Use `new` to **hide** a base method â€” NOT override it.

```csharp
class Animal
{
    public void Speak() => Console.WriteLine("Animal speaks");
}

class Parrot : Animal
{
    public new void Speak() => Console.WriteLine("Parrot talks");
}
```

```csharp
Animal a = new Parrot();
a.Speak(); // ðŸ‘‰ Animal speaks âŒ (not overridden)
```

### âš ï¸ Why use `new`?

- To **intentionally hide** a method (usually not recommended)
- But prefer `override` + `virtual` for **proper polymorphism**

---

## ðŸ§  Summary Table

| Keyword    | Use In        | Purpose                              | Can Call Base?  | Must Override? |
| ---------- | ------------- | ------------------------------------ | --------------- | -------------- |
| `virtual`  | Base class    | Allow overriding                     | âœ… Yes          | âŒ No          |
| `override` | Derived class | Replace base virtual method          | âœ… Yes          | âœ… Yes         |
| `abstract` | Base class    | Define method without implementation | âŒ No (no body) | âœ… Yes         |
| `new`      | Derived class | Hide method in base class            | âŒ No (hides)   | âŒ No          |

---

## ðŸ’¬ Interview-Ready Quote

> â€œPolymorphism allows calling methods on base types while executing derived type behavior. Using `virtual`, `override`, and `abstract`, we separate _what_ something does from _how_ it does it.â€

---

## ðŸ§ª Real-World Analogy

```csharp
abstract class Employee { public abstract decimal CalculatePay(); }

class Developer : Employee {
    public override decimal CalculatePay() => 8000m;
}

class Manager : Employee {
    public override decimal CalculatePay() => 10000m;
}
```

```csharp
List<Employee> team = new() { new Developer(), new Manager() };
foreach (var e in team)
    Console.WriteLine(e.CalculatePay()); // Different pay, same call
```

---

## âœ… Best Practices

| Do                                                         | Donâ€™t                                          |
| ---------------------------------------------------------- | ---------------------------------------------- |
| Prefer `virtual/override` for polymorphism                 | Avoid `new` unless necessary                   |
| Use `abstract` when base class makes no sense to implement | Donâ€™t instantiate abstract classes             |
| Apply polymorphism through base class or interface         | Donâ€™t switch on type if polymorphism can do it |
