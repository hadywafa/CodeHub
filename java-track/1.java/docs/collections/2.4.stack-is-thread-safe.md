# üß™ Java Example: Demonstrating `Stack` Thread Safety

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) throws InterruptedException {
        Stack<Integer> stack = new Stack<>();

        // üßµ Thread 1: Push numbers slowly
        Thread pusher = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                stack.push(i);
                System.out.println("‚¨ÜÔ∏è Pushed: " + i);
                sleep(100); // Delay for visibility
            }
            System.out.println("‚úÖ Pusher done");
        });

        // üßµ Thread 2: Pop numbers slowly
        Thread popper = new Thread(() -> {
            int count = 0;
            while (count < 10) {
                synchronized (stack) {
                    if (!stack.isEmpty()) {
                        int popped = stack.pop();
                        System.out.println("‚¨áÔ∏è Popped: " + popped);
                        count++;
                    } else {
                        System.out.println("‚è≥ Stack empty, waiting...");
                    }
                }
                sleep(150); // Delay for visibility
            }
            System.out.println("‚úÖ Popper done");
        });

        // Start both threads
        pusher.start();
        popper.start();

        // Wait for completion
        pusher.join();
        popper.join();

        // üì¶ Final state
        System.out.println("üì¶ Final stack size: " + stack.size());
    }

    // üí§ Reusable sleep helper
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // Best practice
            System.err.println("Sleep interrupted");
        }
    }
}
```

---

üß™ Sample Output:

```ini
‚¨ÜÔ∏è Pushed: 0
‚è≥ Stack empty, waiting...
‚¨ÜÔ∏è Pushed: 1
‚¨áÔ∏è Popped: 1
‚¨ÜÔ∏è Pushed: 2
‚¨áÔ∏è Popped: 2
...
‚úÖ Pusher done
‚úÖ Popper done
üì¶ Final stack size: 0
```

---

## üß† Why This Works

- `Stack` methods (`push`, `pop`, etc.) are synchronized = **thread-safe**
- But to avoid timing issues like checking `.isEmpty()` and then `.pop()` in another thread, we wrap the whole pop logic in a `synchronized(stack)` block.

---

## üß® What If You Use `ArrayList` Instead?

Replace `Stack<Integer> stack = new Stack<>();` with:

```java
List<Integer> stack = new ArrayList<>();
```

Then run the same code without external synchronization (`synchronized(stack)`), and you may get:

```java
Exception in thread "Thread-1" java.lang.IndexOutOfBoundsException
```

Because `ArrayList` is **not thread-safe** ‚Äî concurrent push/pop corrupts its internal structure.

---

## ‚úÖ Summary

| Operation                                    | Safe with Stack?                           | Why?         |
| -------------------------------------------- | ------------------------------------------ | ------------ |
| `push()`                                     | ‚úÖ Yes                                     | Synchronized |
| `pop()`                                      | ‚úÖ Yes                                     | Synchronized |
| Combo check-then-act (`isEmpty()` ‚Üí `pop()`) | ‚ö†Ô∏è Not safe unless externally synchronized |              |
