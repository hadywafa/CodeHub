# ğŸ“Š Pagination, Sorting & Filtering (Handling Big Datasets)

## ğŸ§© Why Do We Need This?

Imagine:

- Youâ€™re building an API for **e-commerce products** ğŸ›’.
- The DB has **10 million items**.
- If the API returns all in one go â†’ ğŸ’¥ server meltdown + client timeout.

ğŸ‘‰ Thatâ€™s why we **page results** (small chunks), **sort them** (consistent order), and **filter them** (only what the client needs).

---

## 1ï¸âƒ£ Pagination

### Common Techniques

#### a) **Offset & Limit** (SQL style)

```http
GET /products?offset=0&limit=10
GET /products?offset=10&limit=10
```

âœ… Simple, easy.  
âŒ Large offsets = slow queries (DB still scans).

---

#### b) **Page & Size** (Human-friendly)

```http
GET /products?page=1&size=10
GET /products?page=2&size=10
```

âœ… Easier for clients.  
âŒ Same large-skip problem for huge datasets.

---

#### c) **Cursor-based** (a.k.a. Keyset pagination)

```http
GET /products?after=product123&limit=10
```

âœ… Super fast for huge datasets.  
âœ… Works great for infinite scroll (social feeds).  
âŒ More complex to implement.

---

### Example Response with Pagination Metadata

```json
{
  "data": [
    { "id": 1, "name": "Laptop" },
    { "id": 2, "name": "Mouse" }
  ],
  "pagination": {
    "page": 1,
    "size": 2,
    "totalPages": 50,
    "totalItems": 100
  }
}
```

---

## 2ï¸âƒ£ Sorting

Let clients control order.

```http
GET /products?sort=price
GET /products?sort=-createdAt   # minus = descending
```

âœ… Useful for ordering by **date, price, rating, etc.**  
âœ… Multiple sorts possible:

```http
GET /products?sort=price,-rating
```

---

## 3ï¸âƒ£ Filtering

Clients rarely need â€œallâ€ data. Let them **filter**.

```http
GET /products?category=electronics&brand=sony&price_lt=500
```

ğŸ‘‰ Common filter styles:

- `field=value` â†’ `?status=active`
- Range queries â†’ `?price_lt=1000&price_gt=100`
- Lists â†’ `?ids=1,2,3`
- Dates â†’ `?createdAfter=2024-01-01`

---

## ğŸ–¼ï¸ Visual Example

<div align="center">

```mermaid
flowchart TD
    A[Client Request] -->|/products?page=2&size=5&sort=price&category=books| B[API Layer]
    B --> C[DB Query]
    C --> D[Only 5 rows, ordered by price, filtered by category]
    D --> E[Response with metadata + links]
```

</div>

---

## ğŸ”— HATEOAS-Style Pagination Links

```json
{
  "data": [ ... ],
  "links": {
    "self": "/products?page=2&size=5",
    "next": "/products?page=3&size=5",
    "prev": "/products?page=1&size=5"
  }
}
```

âœ… Helps clients **navigate** easily.

---

## âš¡ Pro Tips

- âœ… Always set **default page size** (e.g., 20).
- âœ… Allow clients to change `size` but enforce **max limit** (e.g., 100).
- âœ… For **real-time feeds** â†’ use **cursor-based pagination**.
- âœ… Document filters & sorts clearly.
- âœ… Keep sorting predictable (always use a tiebreaker field like `id`).

---

## âœ… Recap

- **Pagination** = split data into smaller chunks.
- **Sorting** = let clients choose order.
- **Filtering** = only return whatâ€™s needed.
- Use **offset/page for simplicity**, **cursor for huge/real-time datasets**.
- Always return **metadata or navigation links**.

> ğŸ’¡ Think of it like Netflix ğŸ¬:
>
> - Pagination = next page of movies
> - Sorting = â€œSort by Popularityâ€
> - Filtering = â€œShow only Sci-Fi under 2 hoursâ€
