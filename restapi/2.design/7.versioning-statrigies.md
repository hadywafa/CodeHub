# ğŸ”¢ Versioning Strategies (URI, Header, Query Param)

## ğŸ§© Why Version APIs?

- APIs live long ğŸ§“ â†’ clients depend on them.
- When you need to **change behavior** (rename fields, new response format, remove legacy features), you canâ€™t break existing clients.
- Versioning = evolve without chaos.

ğŸ‘‰ Rule: _Donâ€™t break old clients. Add new versions._

---

## ğŸ“Œ Common Versioning Strategies

### 1ï¸âƒ£ URI Versioning (Most Popular)

Put the version directly in the URL.

Example:

```http
GET /api/v1/users/42
GET /api/v2/users/42
```

âœ… Easy to understand.  
âœ… Clear separation of versions.  
âŒ URL changes â†’ not truly â€œRESTfulâ€ (resource identity shifts).  
âŒ Duplicated docs/endpoints if not managed carefully.

ğŸ‘‰ Best when: Big breaking changes.

---

### 2ï¸âƒ£ Query Parameter Versioning

Version specified in query string.

Example:

```http
GET /users/42?version=1
GET /users/42?version=2
```

âœ… Easy to implement.  
âœ… Clients can choose versions dynamically.  
âŒ Less common, often seen as â€œmessyâ€.  
âŒ Harder to cache (different query = different resource).

ğŸ‘‰ Best when: You want quick & flexible version selection.

---

### 3ï¸âƒ£ Header Versioning

Version declared in request headers (`Accept` or custom header).

Example:

```http
GET /users/42
Accept: application/vnd.myapi.v2+json
```

or

```http
X-API-Version: 2
```

âœ… Clean URIs (no version in path).  
âœ… True to REST philosophy (same resource, different representation).  
âŒ Clients must know headers â†’ harder to test/debug.  
âŒ Hidden from URL â†’ less obvious for humans.

ğŸ‘‰ Best when: You want to keep URLs stable & â€œpure RESTâ€.

---

## ğŸ§‘â€ğŸ’» Real-Life Examples

- **GitHub API** â†’ uses **Header Versioning** with media types:

  ```http
  Accept: application/vnd.github.v3+json
  ```

- **Stripe API** â†’ uses **Date-based Versioning** in headers:

  ```http
  Stripe-Version: 2022-11-15
  ```

- **Google APIs** â†’ use **URI Versioning**:

  ```ini
  https://www.googleapis.com/drive/v3/files
  ```

---

## ğŸ–¼ï¸ Visual Comparison

<div align="center">

```mermaid
flowchart TD
    A[URI Versioning] -->|/api/v1/users| B[Clear but URL changes]
    C[Query Param Versioning] -->|/users?version=2| D[Flexible but messy]
    E[Header Versioning] -->|Accept: v2| F[Clean URIs but hidden]
```

</div>

---

## âš¡ Pro Tips

- âœ… Choose **one strategy** and stick with it.
- âœ… URI versioning is easiest for public APIs.
- âœ… Header versioning is cleanest but needs good docs.
- âœ… Avoid â€œsilent changesâ€ â†’ always bump version for breaking changes.
- âœ… Use **semantic versioning** in docs, even if not in URLs (`v1.2`, `v2`).
- âœ… Deprecate old versions gradually (warn before removing).

---

## âœ… Recap

- **URI versioning** â†’ `/v1/` in path (most common).
- **Query param** â†’ `?version=2` (quick & dirty).
- **Header** â†’ `Accept` or `X-API-Version` (cleaner, but hidden).
- Versioning = protecting old clients while evolving new features.

> ğŸ’¡ Think of versioning like Netflix profiles â€” everyone gets their own experience without messing with others.
