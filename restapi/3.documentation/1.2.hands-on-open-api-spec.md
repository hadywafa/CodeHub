# üß≠ What is an OpenAPI spec (in practice)?

A single **YAML or JSON document** that describes:

- your **endpoints** (paths + methods),
- their **inputs** (path/query/header/body),
- their **outputs** (status codes + response bodies),
- shared **schemas** (models),
- **auth**,
- **servers** (environments),
- **examples** and **errors**.

Use **YAML** whenever possible; it‚Äôs friendlier.

---

## üß± The minimal skeleton (copy/paste)

```yaml
openapi: 3.0.3
info:
  title: Example API
  version: 1.0.0
servers:
  - url: https://api.example.com
paths: {} # you‚Äôll fill this
components: {} # shared stuff (schemas, auth, etc.)
```

---

## üß© Build it step by step

### 1) Define a path + method

```yaml
paths:
  /users/{id}:
    get:
      summary: Get a user by ID
      description: Returns a single user
      tags: [Users]
      parameters:
        - name: id
          in: path
          required: true
          description: The user ID
          schema: { type: integer, format: int64, minimum: 1 }
      responses:
        "200":
          description: User found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "404":
          description: Not found
```

### 2) Add request bodies (for POST/PUT/PATCH)

```yaml
paths:
  /users:
    post:
      summary: Create a user
      tags: [Users]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/UserCreate" }
            examples:
              valid:
                value: { name: "Ali", email: "ali@example.com" }
      responses:
        "201":
          description: Created
          headers:
            Location:
              description: URL of the new user
              schema: { type: string }
          content:
            application/json:
              schema: { $ref: "#/components/schemas/User" }
        "422":
          description: Validation error
          content:
            application/problem+json:
              schema: { $ref: "#/components/schemas/Problem" }
```

### 3) Reuse with components/schemas

```yaml
components:
  schemas:
    User:
      type: object
      required: [id, name, email]
      properties:
        id: { type: integer, format: int64 }
        name: { type: string, minLength: 1, maxLength: 120 }
        email: { type: string, format: email }
        role:
          type: string
          enum: [admin, editor, viewer]
    UserCreate:
      type: object
      required: [name, email]
      properties:
        name: { type: string, minLength: 1, maxLength: 120 }
        email: { type: string, format: email }
    Problem: # problem+json (RFC 7807)
      type: object
      properties:
        type: { type: string, format: uri }
        title: { type: string }
        status: { type: integer }
        detail: { type: string }
        instance: { type: string }
      additionalProperties: true
```

### 4) Add query parameters (filter, sort, pagination)

```yaml
paths:
  /users:
    get:
      tags: [Users]
      summary: List users
      parameters:
        - in: query
          name: page
          schema: { type: integer, minimum: 1, default: 1 }
        - in: query
          name: size
          schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
        - in: query
          name: sort
          description: Comma-separated fields, prefix with - for desc
          schema: { type: string, example: "name,-createdAt" }
        - in: query
          name: role
          schema: { type: string, enum: [admin, editor, viewer] }
      responses:
        "200":
          description: Paged users
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserPage"
components:
  schemas:
    UserPage:
      type: object
      properties:
        data:
          type: array
          items: { $ref: "#/components/schemas/User" }
        pagination:
          type: object
          properties:
            page: { type: integer }
            size: { type: integer }
            totalItems: { type: integer }
            totalPages: { type: integer }
```

### 5) Describe authentication (Bearer/JWT)

```yaml
components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

security: # apply globally (can override per-operation)
  - BearerAuth: []
```

### 6) File upload/download (at the spec level)

**Multipart upload:**

```yaml
paths:
  /files:
    post:
      summary: Upload a file
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required: [file]
              properties:
                file:
                  type: string
                  format: binary
                description:
                  type: string
      responses:
        "201":
          description: Created
          content:
            application/json:
              schema:
                type: object
                properties:
                  id: { type: string }
                  contentType: { type: string }
                  size: { type: integer }
```

**Binary download with filename:**

```yaml
paths:
  /files/{id}:
    get:
      summary: Download file
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        "200":
          description: File stream
          headers:
            Content-Disposition:
              description: Suggested filename
              schema: { type: string, example: 'attachment; filename="report.pdf"' }
          content:
            application/octet-stream:
              schema:
                type: string
                format: binary
        "404":
          description: Not found
```

### 7) Examples and examples!

- **Inline examples** help consumers understand quickly.
- You can also centralize examples under `components/examples`.

```yaml
components:
  examples:
    UserExample:
      summary: A sample user
      value: { id: 42, name: "Ali", email: "ali@example.com" }
```

Use it:

```yaml
content:
  application/json:
    schema: { $ref: "#/components/schemas/User" }
    examples:
      default:
        $ref: "#/components/examples/UserExample"
```

### 8) Advanced schema composition (`oneOf` / `anyOf` / `allOf`)

- **`allOf`** = merge (inheritance/extension).
- **`oneOf`** = exactly one matches (polymorphism).
- **`anyOf`** = at least one matches.

```yaml
components:
  schemas:
    BaseItem:
      type: object
      properties: { id: { type: string }, type: { type: string } }
      required: [id, type]

    Book:
      allOf:
        - $ref: "#/components/schemas/BaseItem"
        - type: object
          properties:
            author: { type: string }
          required: [author]

    Movie:
      allOf:
        - $ref: "#/components/schemas/BaseItem"
        - type: object
          properties:
            director: { type: string }
          required: [director]

    CatalogItem:
      oneOf:
        - $ref: "#/components/schemas/Book"
        - $ref: "#/components/schemas/Movie"
      discriminator:
        propertyName: type
        mapping:
          book: "#/components/schemas/Book"
          movie: "#/components/schemas/Movie"
```

### 9) Versioning and servers

Expose multiple environments or versions:

```yaml
servers:
  - url: https://api.example.com/v1
    description: Production v1
  - url: https://staging-api.example.com/v1
    description: Staging
```

(Or version with headers and keep `servers` stable.)

### 10) Tags, grouping, and descriptions

```yaml
tags:
  - name: Users
    description: Operations about user resources
  - name: Files
    description: Upload & download

paths:
  /users:
    get:
      tags: [Users]
      summary: List users
      description: Returns a paginated list of users.
```

---

## üß™ A tiny but complete spec (fits on one page)

```yaml
openapi: 3.0.3
info: { title: Mini Users API, version: 1.0.0 }
servers: [{ url: https://api.example.com }]
tags:
  - name: Users
  - name: Files
paths:
  /users:
    get:
      tags: [Users]
      summary: List users
      parameters:
        - in: query
          name: page
          schema: { type: integer, default: 1, minimum: 1 }
        - in: query
          name: size
          schema: { type: integer, default: 20, minimum: 1, maximum: 100 }
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema: { $ref: "#/components/schemas/UserPage" }
    post:
      tags: [Users]
      summary: Create user
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/UserCreate" }
      responses:
        "201":
          description: Created
          headers:
            Location:
              schema: { type: string }
  /users/{id}:
    get:
      tags: [Users]
      summary: Get user
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: integer, format: int64, minimum: 1 }
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema: { $ref: "#/components/schemas/User" }
        "404": { description: Not found }
  /files:
    post:
      tags: [Files]
      summary: Upload file
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              required: [file]
              properties:
                file: { type: string, format: binary }
      responses:
        "201":
          description: Created
          content:
            application/json:
              schema:
                type: object
                properties:
                  id: { type: string }
                  size: { type: integer }
                  contentType: { type: string }
components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    User:
      type: object
      required: [id, name, email]
      properties:
        id: { type: integer, format: int64 }
        name: { type: string }
        email: { type: string, format: email }
    UserCreate:
      type: object
      required: [name, email]
      properties:
        name: { type: string, minLength: 1 }
        email: { type: string, format: email }
    UserPage:
      type: object
      properties:
        data:
          type: array
          items: { $ref: "#/components/schemas/User" }
        pagination:
          type: object
          properties:
            page: { type: integer }
            size: { type: integer }
            totalItems: { type: integer }
            totalPages: { type: integer }
```

---

## ‚úÖ Quality checklist (use this every time)

- **Info**: `title`, `version` set.
- **Servers**: prod + staging URLs.
- **Tags**: endpoints grouped logically.
- **Paths**: each operation has `summary`, `parameters`/`requestBody`, `responses`.
- **Schemas**: required fields, enums, formats, min/max.
- **Errors**: consistent model (e.g., `Problem` RFC 7807).
- **Auth**: `securitySchemes` + `security` applied.
- **Examples**: add at least one per major operation.
- **Consistency**: pagination, sorting, filtering patterns reused.

---

## üõ†Ô∏è Tools you‚Äôll actually use

- **Swagger Editor** (browser) ‚Üí write/validate YAML live.
- **Swagger UI / Redoc** ‚Üí pretty, interactive docs.
- **OpenAPI Generator** ‚Üí generate client SDKs (C#, JS/TS, Python‚Ä¶) and server stubs.
- **Spectral** (linter) ‚Üí enforce style rules across specs.
