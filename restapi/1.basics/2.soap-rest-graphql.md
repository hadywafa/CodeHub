# 🔄 REST vs SOAP vs GraphQL

APIs come in different flavors.  
Think of them like **different styles of restaurants** 🍽️:

- **SOAP** → a fancy 7-course dinner with strict rules.
- **REST** → a casual restaurant with a simple menu.
- **GraphQL** → a “make your own bowl” place where you pick exactly what you want.

---

## 🧩 SOAP (Simple Object Access Protocol)

**Definition:**
SOAP is a protocol (not just a style). It uses XML for messages and has very strict standards.

### 🔎 Characteristics

- ✅ **Formal contract**: Uses WSDL (Web Services Description Language).
- ✅ **Strong typing**: Each request/response follows strict schemas.
- ✅ **Extensive features**: Built-in standards for security, transactions, reliability.
- ❌ **Verbose**: XML-heavy, bloated requests.
- ❌ **Rigid**: Harder to evolve compared to REST or GraphQL.

### 🛠 Example SOAP request

```xml
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUserRequest>
      <UserId>1</UserId>
    </GetUserRequest>
  </soap:Body>
</soap:Envelope>
```

👉 SOAP is like **old enterprise banking software** — still alive where rules and reliability matter most.

---

## 🌳 REST (Representational State Transfer)

**Definition:**
REST is an **architectural style** that uses HTTP verbs + URLs to work with resources.

### 🔎 Characteristics

- ✅ **Simple**: Works over HTTP with JSON/XML.
- ✅ **Stateless**: Each request is independent.
- ✅ **Lightweight**: Less verbose than SOAP.
- ❌ **Over-fetching**: You may get more data than needed.
- ❌ **Under-fetching**: Sometimes you need multiple calls for all required data.

### 🛠 Example REST request

```http
GET /users/1 HTTP/1.1
Host: api.example.com
Accept: application/json
```

Response:

```json
{
  "id": 1,
  "name": "Ali",
  "email": "ali@example.com"
}
```

👉 REST is like a **regular menu** — you order a dish, you get the whole dish, even if you only wanted the fries 🍟.

---

## 🔮 GraphQL (Query Language for APIs)

**Definition:**
GraphQL is a **query language + runtime**.
Instead of multiple endpoints, you have **one endpoint** and specify exactly what data you need.

### 🔎 Characteristics

- ✅ **Client-driven**: Clients control what fields they want.
- ✅ **One endpoint**: No multiple URLs to remember.
- ✅ **Efficient**: Avoids over-fetching/under-fetching.
- ❌ **Complex**: More work for backend (resolvers, schema).
- ❌ **Caching harder**: Since queries differ, HTTP caching is trickier.

### 🛠 Example GraphQL query

```graphql
query {
  user(id: 1) {
    name
    email
  }
}
```

Response:

```json
{
  "data": {
    "user": {
      "name": "Ali",
      "email": "ali@example.com"
    }
  }
}
```

👉 GraphQL is like a **build-your-own bowl** 🥗 — you pick rice + chicken + sauce, and that’s all you get, no extras.

---

## 📊 Comparison Table

| Feature        | SOAP 🏛️                     | REST 🌳                         | GraphQL 🔮                       |
| -------------- | --------------------------- | ------------------------------- | -------------------------------- |
| Type           | Protocol (strict rules)     | Architectural style             | Query language & runtime         |
| Data format    | XML only                    | JSON, XML, etc.                 | JSON                             |
| Contract       | WSDL                        | OpenAPI/Swagger optional        | Strongly typed schema            |
| Endpoint style | Single endpoint w/ actions  | Multiple endpoints (resources)  | Single endpoint w/ queries       |
| Flexibility    | Low                         | Medium                          | High                             |
| Verbosity      | Very high                   | Medium                          | Low                              |
| Use cases      | Enterprise, banking, legacy | Web services, APIs, mobile apps | Modern apps, APIs for UI/clients |

---

## 🎯 Quick Recap

- **SOAP** → heavy, XML, enterprise-grade (banking, payments).
- **REST** → lightweight, simple, most common today.
- **GraphQL** → flexible, modern, perfect for complex UIs.
