# ğŸ—‚ï¸ Caching in REST APIs (ETag, Last-Modified, Cache-Control)

## ğŸ§© Why Caching Matters

- Every time you hit an API â†’ the server, DB, and network are stressed.
- Without caching â†’ repeated requests = wasted time + money ğŸ’¸.
- With caching â†’ the client can reuse responses safely.

ğŸ‘‰ Goal: Serve data **fast** without breaking **freshness**.

---

## ğŸ”‘ The Building Blocks

Caching in HTTP has 3 main tools:

1. **Cache-Control** â†’ how long/manner a response can be cached.
2. **Last-Modified** â†’ tells client when resource last changed.
3. **ETag (Entity Tag)** â†’ fingerprint/hash of resource for change detection.

Letâ€™s break them down.

---

## 1ï¸âƒ£ Cache-Control

The **`Cache-Control` header** tells browsers/proxies how to cache.

### Example:

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=3600
```

- `public` â†’ anyone (browser, proxy, CDN) can cache it.
- `max-age=3600` â†’ valid for 3600s (1 hour).

### Variants

- `no-store` â†’ donâ€™t cache at all.
- `no-cache` â†’ can store, but must **revalidate with server** before reuse.
- `private` â†’ only the browser can cache, not proxies.

ğŸ‘‰ Think of it like **expiry labels** on food ğŸ.

---

## 2ï¸âƒ£ Last-Modified

The **`Last-Modified` header** tells client when resource last changed.

### Response Example

```http
HTTP/1.1 200 OK
Last-Modified: Tue, 30 Sep 2025 10:00:00 GMT
```

### Next Client Request

```http
GET /users/42
If-Modified-Since: Tue, 30 Sep 2025 10:00:00 GMT
```

- If resource hasnâ€™t changed â†’ server returns `304 Not Modified`.
- Saves bandwidth, because the **body isnâ€™t resent**.

---

## 3ï¸âƒ£ ETag (Entity Tag)

ETag = unique **fingerprint** of a resource (often a hash).

### Response Example

```http
HTTP/1.1 200 OK
ETag: "abc123"
```

### Next Client Request

```http
GET /users/42
If-None-Match: "abc123"
```

- If same â†’ server replies `304 Not Modified`.
- If different â†’ server sends new version with new ETag.

ğŸ‘‰ Safer than `Last-Modified` because:

- Handles updates faster than seconds.
- Works even if clocks differ.

---

## ğŸ–¼ï¸ Sequence Flow

<div align="center">

```mermaid
sequenceDiagram
    participant Client
    participant API
    Client->>API: GET /users/42
    API-->>Client: 200 OK + ETag: "v1"
    Client->>API: GET /users/42 (If-None-Match: "v1")
    API-->>Client: 304 Not Modified (no body sent)
```

</div>

---

## ğŸ”§ Practical Example: User Profile

### First Request

```http
GET /users/42
```

Response:

```http
200 OK
Cache-Control: private, max-age=600
ETag: "user42-v1"
Content-Type: application/json
```

```json
{ "id": 42, "name": "Ali", "email": "ali@example.com" }
```

---

### Second Request (after 5 mins)

```http
GET /users/42
If-None-Match: "user42-v1"
```

Response:

```http
304 Not Modified
```

ğŸ‘‰ No JSON body sent â†’ client just reuses cached copy.

---

## âš¡ Combining Strategies

- `Cache-Control` â†’ for **expiry rules**.
- `ETag` â†’ for **change detection**.
- `Last-Modified` â†’ for **human-readable timestamps**.

A good API usually uses both `Cache-Control` + `ETag`.

---

## âœ… Best Practices

- âœ… Use `ETag` for dynamic resources.
- âœ… Use `Cache-Control` headers for static assets (images, docs).
- âœ… Use `private` for user-specific data (profiles, dashboards).
- âœ… For public content â†’ `public, max-age=86400` (cache 1 day).
- âœ… Always allow conditional requests (`If-None-Match`, `If-Modified-Since`).

---

## âœ… Recap

- Caching = speed + scalability.
- **Cache-Control** defines caching rules.
- **Last-Modified** enables timestamp-based revalidation.
- **ETag** enables hash-based revalidation (more reliable).
- Together â†’ APIs serve **fresh data fast**, while saving resources.

> ğŸ’¡ Think of caching like a **fridge**: you donâ€™t cook the same meal every time â€” you reuse it until it goes bad.
