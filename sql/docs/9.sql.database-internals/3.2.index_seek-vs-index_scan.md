# ðŸ”Ž **Index Seek vs. Index Scan: A Deep Dive**

Indexes help databases **retrieve data efficiently**, but the way they are usedâ€”either via **Index Seek or Index Scan**â€”greatly affects **query performance**.

âœ… **Index Seek** efficiently **navigates the B-Tree index**, **loads only necessary index pages into memory**, retrieves the **row IDs (RID)**, and fetches **only the required data pages**.  
âŒ **Index Scan** **loads all index pages and data pages into memory**, then **applies the filter in RAM**, making it **much slower** for large datasets.

---

## **ðŸ“Œ How Indexes Store Data (B-Tree Structure)**

Indexes are **stored in structured pages** using a **B-Tree (Balanced Tree) structure**, with three levels:

| **Page Type**          | **Function**                                                      |
| ---------------------- | ----------------------------------------------------------------- |
| **Root Page**          | Entry point for searches, stores pointers to intermediate pages.  |
| **Intermediate Pages** | Store **pointers to leaf pages** for faster lookups.              |
| **Leaf Pages**         | Contain **Row IDs (RID)** or **actual data (Clustered Indexes).** |

âœ… **Index pages are separate from data pages** and allow fast lookups.

---

## **ðŸ“Œ What is Index Seek?**

âœ” **Index Seek is a targeted search** that **navigates the B-Tree structure**, locates **only relevant rows**, and retrieves **only required data pages**.

### **ðŸ”¹ Lifecycle of an Index Seek**

**1ï¸âƒ£ Index Pages Are Loaded into Memory:**

- The **query optimizer** chooses an **Index Seek**.
- The **Root Page** of the index **is loaded into memory**.
- The **B-Tree algorithm** is applied to **find the row location**.

**2ï¸âƒ£ B-Tree Traversal Finds the Row ID (RID):**

- The index **searches efficiently** using **logarithmic O(log N) complexity**.
- The **Leaf Page is reached**, containing the **Row ID (RID)**.

**3ï¸âƒ£ Data Page Is Retrieved Using RID:**

- The **exact data page** is fetched based on **row pointers**.
- **Only necessary pages are read** from disk.

**4ï¸âƒ£ Data Is Returned to the Query Engine:**

- The **required row(s)** are sent back to the client.

---

### **ðŸ” Example: How Index Seek Works**

âœ” **Scenario: Searching for `id = 1001` in an Index**

```sql
SELECT * FROM Employees WHERE id = 1001;
```

| **Index Level**                 | **Page Content**                                             |
| ------------------------------- | ------------------------------------------------------------ |
| **Root Page**                   | Pointers to **Intermediate Pages**                           |
| **Intermediate Page 1**         | Pointers to **Leaf Pages (id: 1 - 1000, 1001 - 2000, etc.)** |
| **Leaf Page (id: 1001 - 2000)** | **Row ID (1001) â†’ Page 50**                                  |
| **Data Page 50**                | Full record: **(1001, Alice, 30, \$5000)**                   |

---

### **ðŸ”¹ Index Seek Execution Process**

```mermaid
sequenceDiagram
    participant SQLClient as SQL Client (User Application) ðŸ’»
    participant QueryEngine as Query Execution Engine ðŸ”
    participant RAM as RAM (Buffer Cache) ðŸ–¥ï¸
    participant Disk as Database Storage ðŸ’½

    Note over SQLClient: 1ï¸âƒ£ User sends query request
    SQLClient->>QueryEngine: Execute `SELECT * FROM Employees WHERE id = 1001`

    Note over QueryEngine: 2ï¸âƒ£ Query Execution Engine starts execution and checks cache
    QueryEngine->>RAM: Check if Index Pages are in Memory

    alt Index Pages Found in RAM
        Note over RAM: âœ… No need to access disk
    else Index Pages Not Found
        QueryEngine->>Disk: Load **Root Index Page**
        Disk->>RAM: Store **Root Index Page**

        Note over RAM: 3ï¸âƒ£ Root Page points to the correct Intermediate Page
        QueryEngine->>Disk: Load **Intermediate Index Page**
        Disk->>RAM: Store **Intermediate Index Page**

        Note over RAM: 4ï¸âƒ£ Intermediate Page points to the correct Leaf Page
        QueryEngine->>Disk: Load **Leaf Index Page**
        Disk->>RAM: Store **Leaf Index Page**

        Note over RAM: 5ï¸âƒ£ Leaf Page contains the Row ID (RID) of the required data row
    end

    QueryEngine->>Disk: Retrieve **Data Page using Row ID (RID 1001)**
    Disk->>RAM: Store **Data Page in Memory**

    Note over RAM: 6ï¸âƒ£ Data Page is now in RAM and ready for processing
    RAM->>QueryEngine: Return **Employee Data (id = 1001, Alice, 30, $5000)**

    Note over QueryEngine: âœ… Query Execution Engine processes the retrieved data
    QueryEngine->>SQLClient: Send Query Result (Employee Data)

    Note over SQLClient: 7ï¸âƒ£ SQL Client receives and displays query results

```

âœ” **Only relevant index pages and the required data page are accessed**.  
âœ” **Efficient B-Tree search avoids reading unnecessary pages**.

---

## **ðŸ“Œ What is Index Scan?**

âŒ **Index Scan reads all index pages sequentially, loads all data pages into memory, and applies the filter later**.

### **ðŸ”¹ Lifecycle of an Index Scan**

**1ï¸âƒ£ Full Index Read:**

- The database **reads the entire index sequentially**.

**2ï¸âƒ£ All Data Pages Are Loaded into Memory:**

- It **does not use row locators**, so it **loads all rows into RAM**.

**3ï¸âƒ£ Filter Applied in Memory:**

- The **filter condition (e.g., `age > 30`)** is evaluated **after loading all pages**.

**4ï¸âƒ£ Results Are Returned:**

- The **matching rows are sent back**, but at a **high CPU and I/O cost**.

---

### **ðŸ” Example: How Index Scan Works**

âœ” **Scenario: Searching for `age > 30`**

```sql
SELECT * FROM Employees WHERE age > 30;
```

| **Index Level** | **Page Content**                            |
| --------------- | ------------------------------------------- |
| **Root Page**   | Pointers to all rows.                       |
| **Leaf Pages**  | Contains **all employee records**.          |
| **Data Pages**  | All pages loaded into RAM before filtering. |

---

### **ðŸ”¹ Index Scan Execution Process**

```mermaid
sequenceDiagram
    participant SQLClient as SQL Client (User Application) ðŸ’»
    participant QueryEngine as Query Execution Engine ðŸ”
    participant RAM as RAM (Buffer Cache) ðŸ–¥ï¸
    participant Disk as Database Storage ðŸ’½

    Note over SQLClient: 1ï¸âƒ£ User sends query request
    SQLClient->>QueryEngine: Execute `SELECT * FROM Employees WHERE age > 30`

    Note over QueryEngine: 2ï¸âƒ£ Query Execution Engine starts execution and checks cache
    QueryEngine->>RAM: Check if Index Pages are in Memory

    alt Index Pages Found in RAM
        Note over RAM: âœ… No need to access disk
    else Index Pages Not Found
        QueryEngine->>Disk: Load **All Index Pages**
        Disk->>RAM: Store **All Index Pages in Memory**
    end

    Note over RAM: 3ï¸âƒ£ Index Pages are scanned sequentially to find Row IDs
    QueryEngine->>RAM: Scan **Leaf Index Pages for matching rows (age > 30)**

    Note over QueryEngine: 4ï¸âƒ£ Query Engine now has Row IDs of matching rows
    QueryEngine->>Disk: Load **All Data Pages (Scanning Entire Table)**

    Disk->>RAM: Store **All Data Pages in Memory**

    Note over RAM: 5ï¸âƒ£ Data Pages are scanned row by row to apply filter (age > 30)
    QueryEngine->>RAM: Apply filter in memory **(age > 30)**

    Note over RAM: 6ï¸âƒ£ Only matching rows are retained in memory
    RAM->>QueryEngine: Return filtered results

    Note over QueryEngine: âœ… Query Execution Engine processes the retrieved data
    QueryEngine->>SQLClient: Send Query Result (Filtered Employee Data)

    Note over SQLClient: 7ï¸âƒ£ SQL Client receives and displays query results

```

âœ” **Index Scan loads the entire table, even if only a few rows are needed**.  
âœ” **Very slow for large tables** because of **high disk I/O & memory usage**.

---

## **ðŸš€ Performance Comparison: Index Seek vs. Index Scan**

| **Feature**      | **Index Seek âœ…**                | **Index Scan âŒ**               |
| ---------------- | -------------------------------- | ------------------------------- |
| **Data Access**  | Uses **B-Tree traversal**        | Reads **all index rows**        |
| **Performance**  | âœ… **Faster (Selective Read)**   | âŒ **Slower (Full Index Scan)** |
| **I/O Overhead** | âœ… **Low (Minimal page reads)**  | âŒ **High (Loads all pages)**   |
| **CPU Cost**     | âœ… **Low (Minimal computation)** | âŒ **High (Filter in memory)**  |

âœ” **Index Seek retrieves data efficiently using structured B-Tree search**.  
âŒ **Index Scan reads unnecessary pages, making it slower for large datasets**.

---

## **ðŸ¤” How to Avoid Index Scans?**

### **âœ… Solution 1: Ensure Queries Use Indexed Columns**

```sql
CREATE INDEX idx_age ON Employees(age);
```

ðŸ”¹ **Now queries using `WHERE age > 30` will perform an Index Seek**.

### **âœ… Solution 2: Use Selective Filters**

âŒ **Bad Query (Index Scan)**

```sql
SELECT * FROM Employees WHERE age > 30;
```

âœ… **Optimized Query (Index Seek)**

```sql
SELECT * FROM Employees WHERE age = 35;
```

ðŸ”¹ **Using equality `=` ensures Index Seek**.

### **âœ… Solution 3: Use Query Hints to Force Index Seek**

```sql
SELECT * FROM Employees WITH (INDEX(idx_age)) WHERE age = 35;
```

ðŸ”¹ **Explicitly instructs the optimizer to use `idx_age`**.

---

## **ðŸ“’ Final Thoughts**

âœ” **Index Seek is faster** because it:

- **Loads only necessary index pages into memory**.
- **Applies B-Tree traversal** for fast lookups.
- **Fetches only the required data pages**.

âœ” **Index Scan is slower** because it:

- **Reads the entire index sequentially**.
- **Loads all data pages into memory before filtering**.
